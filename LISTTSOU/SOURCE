LISTTSOU TITLE '                             L I S T   O N L I N E   T >
               S O   U S E R S'
***********************************************************************
*                                                                     *
* Title -- LISTTSOU                                                   *
*                                                                     *
* Function / Operation -- LISTTSOU displays currently active TSO      *
*   users.                                                            *
*                                                                     *
* Attributes -- LISTTSOU is reenterable, refreshable and reusable.    *
*   It operates as a TSO command processor in TCB mode, problem state *
*   and problem key.  It uses no APF restricted operating system      *
*   services.                                                         *
*                                                                     *
* Status / Change Level --                                            *
*   V1L0 -- August 2013                                               *
*                                                                     *
* External routines --                                                *
*   QSORTL, MINIFMT, IKJPARS, IKJEFF02                                *
*     QSORTL and MINIFMT are statically linked with LISTTSOU,         *
*     IKJPARS and IKJEFF02 are called using addresses in the CVT or   *
*     by LINK or LOAD and CALL if their addresses are not in the CVT. *
*                                                                     *
* Command Line --                                                     *
*   LISTTSOU  SORT(ASID|USERID)  ASID  VERSION                        *
*                                                                     *
* Method of Operation --                                              *
*   LISTTSO scans the ASCBs using GUPI methods.  When it finds a TSO  *
*   user it saves the userid and its associated ASID.  After it has   *
*   scanned the ASCBs it sorts the saved user list by user id         *
*   using the QSORTL external fiction.  Finally, it builds output     *
*   lines using the sorted user list and displays the users.          *
*                                                                     *
* Messages --                                                         *
*   LTSU001I THE FOLLOWING TSO USERS ARE CURRENTLY ACTIVE --          *
*    uuu(X'hhhh') uuu(X'hhhh') ...                                    *
*    Reason -- LISTTSOU is displaying the users currently online.     *
*     The (X'nnnn') text is present when the ASID option is specified *
*     on the command line.  The user list is sorted by the userid     *
*     unless the command line specifies SORT(ASID).                   *
*                                                                     *
*    Action -- LISTTSOU creates as many output lines as are required  *
*     to display the active users.  It then terminates.               *
*    Response -- None required.                                       *
*                                                                     *
*   LTSU002I NO TSO USERS ARE PRESENTLY ACTIVE                        *
*    Reason -- LISTTSOU found no active TSO users.  This message      *
*     appears only when LISTTSOU executes in batch.                   *
*    Action -- LISTTSOU terminates.                                   *
*    Response -- If this messages appears when LISTTSOU is run in a   *
*     TSO seesion, it probably indicates an error in LISTSOU; it      *
*     should disply the userid of the user running LISTTSOU.          *
*                                                                     *
*   LTSU003I LISTTSOU VERSION v LEVEL l ASSEMBLED ON mm/dd/yy AT      *
*   hh:mm                                                             *
*    Reason: The VERSION option was specified in the command line,    *
*     the command is reporting its version and level.                 *
*   Action: LISTTSOU continues execution.                             *
*   Response: None required.                                          *
*                                                                     *
* Notes -- The messages issued by LISTTSO can be saved using the      *
*   Rexx and CLIST outtrap function, and can be retrieved and         *
*   processed by the Rexx exec or CLIST.  LISTTSOU can operate in     *
*   the TSO in batch environment and its output messages will         *
*   appear in the data set specified by the SYSTSPRT DD statement.    *
*                                                                     *
***********************************************************************
         SPACE 5
         PUSH  PRINT
         PRINT NOGEN
LISTTSOU RSECT                     DEFINE THE PROGRAM CSECT
         SPACE 2
SA       DSECT
SARESV   DS    F
SAHSA    DS    A                   -> HIGHER SAVE AREA
SALSA    DS    A                   -> LOWER SAVE AREA
SAREG14  DS    F                   REGISTER 14
SAREG15  DS    F                   REGISTER 15
SAREG00  DS    F                   REGISTER 0
SAREG01  DS    F                   REGISTER 1
SAREG02  DS    F                   REGISTER 2
SAREG03  DS    F                   REGISTER 3
SAREG04  DS    F                   REGISTER 4
SAREG05  DS    F                   REGISTER 5
SAREG06  DS    F                   REGISTER 6
SAREG07  DS    F                   REGISTER 7
SAREG08  DS    F                   REGISTER 8
SAREG09  DS    F                   REGISTER 9
SAREG10  DS    F                   REGISTER 10
SAREG11  DS    F                   REGISTER 11
SAREG12  DS    F                   REGISTER 12
         SPACE 2
AUSER    DSECT                     AN ONLINE TSO USER
AUNEXT   DS    A                   -> NEXT USER
AUUSERID DS    CL8                 THE USERID
AUUSER   EQU   AUUSERID,L'AUUSERID
AUASID   DS    H
         DS    0D
AUSIZE   EQU   *-AUSER             LENGTH
         SPACE 2
         IKJCPPL ,                 DEFINE TSO CPPL
RCBUF    EQU   6+(CPPLCBUF-CPPL)/4 REGISTERS CONTAINING CPPL
RPSCB    EQU   6+(CPPLPSCB-CPPL)/4  POINTERS AFTER CPPL LOADED
RUPT     EQU   6+(CPPLUPT-CPPL)/4    INTO REGISTERS 6 THROUGH 9
RECT     EQU   6+(CPPLECT-CPPL)/4
         SPACE 2
         IKJPPL ,                  DEFINE TSO PARSE PARAMETER LIST
PPLSIZE  EQU   *-PPL
         SPACE 2
WA       DSECT                     WORK AREA
USERLIST DS    A                   ADDRESS OF THE FIRST AUSER
FF02ADDR DS    A                   ADDRESS OF IKJEFF02
WAECB    DS    F                   ECB
WAPDL    DS    F
         IKJEFFMT MTFORMAT=NEW,MTDSECT=NO  IKJEFF02 PARAMETER LIST    ->
                                            AND  PARAMETER DATA
FMTWORK  DS    XL200               MINIFMT WORK AREA
SORTPARM CALL  ,(*-*,*-*,*-*),MF=L QSORTL PARAMETER LIST
OUTLINE  DS    CL78                OUTPUT LINE
OUTLINEE EQU   *                   END OF OUTPUT LINE
SAVEAREA DS    9D                  72 BYTE OS/360 SAVE AREA
WAPPL    DS    XL(PPLSIZE)         STORAGE FOR A PPL
SORTOPT  DS    AL1
SORTASID EQU   X'80'               SORT BY ASID
ASID     EQU   X'01'               DISPLAY ASIDS
         DS    0D
WASIZE   EQU   *-WA                WORK AREA SIZE
         SPACE 2
         CVT   DSECT=YES
         IHAASVT ,
         IHAASCB .
         IEECHAIN ,
         POP   PRINT
         EJECT
LISTTSOU RSECT                     RETURN TO PROGRAM CSECT
LISTTSOU AMODE 31                  PROGRAM AMODE
LISTTSOU RMODE ANY                 PROGRAM RMODE
         USING WA,11               DEFINE WORK AREA ADDRESSABILITY
         USING PPL,WAPPL           DEFINE PPL ADDRESSABILITY
         USING *,12                DEFINE PROGRAM ADDRESSABILITY
         SAVE  (14,12),,'LISTTSOU &SYSDATE &SYSTIME'  SAVE REGISTERS
         LR    12,15               COPY ENTRY POINT ADDRESS TO REG 12
         LR    2,1                 COPY CPPL ADDRESS TO REG 2
         LM    6,9,0(2)            LOAD THE CPPL INTO REGS 6 TO 9
         LHI   5,WASIZE            LOAD THE WORK AREA SIZE
         GETMAIN RU,LV=(5)         GET WORK AREA STORAGE
         SR    15,15               SET REG 15 = 0
         LR    4,1                 COPY WORK AREA ADDRESS TO REG 4
         LR    11,1                  AND REG 11
         MVCL  4,14                CLEAR THE WORK AREA
         LA    15,SAVEAREA         LOAD ADDR OF THE NEW SAVE AREA
         ST    13,4(,15)           ADD NEW SAVE AREA TO THE
         ST    15,8(,13)            SAVE AREA CHAIN
         LR    13,15               ESTABLISH NEW SAVE AREA POINTER
         ST    2,MTCPPLP           SAVE THE CPPL ADDRESS FOR IKJEFF02
         ST    RCBUF,PPLCBUF       INITIALIZE THE PARSE PARAMETER LIST
         ST    RECT,PPLECT
         ST    RUPT,PPLUPT
         LA    0,WAECB
         ST    0,PPLECB
         L     0,=A(LISTTSOP)
         ST    0,PPLPCL
         LA    0,WAPDL
         ST    0,PPLANS
         L     10,CVTPTR           LOAD ADDRESS OF THE CVT
         ICM   0,B'1111',CVTEFF02-CVTMAP(10)  LOAD THE ADDR OF IKJEFF02
         JNZ   GOTFF02             BR IF THE ADDR IS IN THE CVT
         LOAD  EPLOC==CL8'IKJEFF02' LOAD IKJEFF02
GOTFF02  ST    0,FF02ADDR          SAVE THE ADDRESS
         MVC   MTCSECTP,=A(LISTTSOM)  INITIALIZE
         LA    0,MTCSECTP              THE
         ST    0,MTPLPTR                IKJEFF02
         MVI   MTSW1,MTPUTLSW            PARAMETER
         MVI   MTSW2,MTFMT                LIST & PARAMETER DATA
         ICM   15,B'1111',CVTPARS-CVTMAP(10)  LOAD ADDRESS OF IKJPARS
         JZ    LINKPARS            BR IF ADDRESS NOT IN THE CVT
         CALL  (15),MF=(E,WAPPL)   CALL IKJPARS
         J     TESTRC              GO TEST THE RETURN CODE
LINKPARS LINK  SF=(E,CALLPARS),MF=(E,WAPPL)  CALL IKJPARS
TESTRC   LTR   15,15               TEST THE RETURN CODE
         JNZ   EXIT                BR IF ERROR
         L     15,WAPDL            LOAD ADDRESS OF THE PDL
         LH    0,PASID-P(,15)      LOAD THE ASID INDEX
         LTR   0,0                 TEST IF ASID SPECIFIED
         BZ    *+L'*+4             BR IF ASID NOT SPECIFIED
         OI    SORTOPT,ASID        INDICATE ASIDS TO BE PRINTED
         LH    0,PVER-P(,15)       LOAD VERSION INDEX
         LTR   0,0                 TEST VALUE
         JZ    NOVER               BR IF VERSION NOT SPECIFIED
         MVC   MTMSGID,=C'MS03'    INIT THE MESSAGE ID
         L     15,FF02ADDR         LOAD ADDRESS OF IKJEFF02
         CALL  (15),MF=(E,MTPARML) WRITE THE VERSION MESSAGE
         L     15,WAPDL            RELOAD ADDRESS OF THE PDL
NOVER    LH    0,PSORTOPT-P(,15)   LOAD THE SORT OPTION INDEX
         CHI   0,2                 COMPARE WITH 2
         JL    *+L'*+4             BR IF SORT(ASID) NOT SPECIFIED
         OI    SORTOPT,SORTASID    SET THE OPTION
         IKJRLSA WAPDL             RELEASE THE PDL
* OBTAIN THE TSO USERS
         L     2,CVTASVT-CVTMAP(,10) LOAD ADDR OF THE ASVT
         L     3,ASVTMAXU-ASVT(,2) LOAD NUMBER OF ASCB ENTRIES
         LA    2,ASVTENTY-ASVT(,2) LOAD ADDR OF THE FIRST ASCB POINTER
FINDTSOU ICM   4,B'1111',0(2)      LOAD AN ASCB ADDRESS
         BNP   SKIPASCB            BR IF THERE IS AN ADDRESS
         ICM   5,B'1111',ASCBCSCB-ASCB(4) LOAD A CSCB ADDRESS
         BZ    SKIPASCB            BR IF NO CSCB
         CLI   CHTRKID-CHAIN(5),CHTSID  TEST IF THIS IS A TSO USER
         BNE   SKIPASCB            BR IF NOT
         LHI   0,AUSIZE            LOAD SIZE OF AN AUSER
         GETMAIN RU,LV=(0)         GET STORAGE FOR AN AUSER
         MVC   AUNEXT-AUSER(,1),USERLIST  ADD THE AUSER TO THE
         ST    1,USERLIST                  USER LIST
         MVC   AUUSER-AUSER(,1),CHKEY-CHAIN(5)  COPY THE USERID
         MVC   AUASID-AUSER(,1),ASCBASID-ASCB(4)  COPY THE ASID
SKIPASCB LA    2,4(,2)             COMPUTE ADDR OF THE NEXT ASCB ADDR
         BCT   3,FINDTSOU          GO CHECK IT
         ICM   0,B'1111',USERLIST  TEST IF ANY USERS
         BNZ   SORTUSER            BR IF SO
         MVC   MTMSGID,=C'MS02'    STORE THE MESSAGE ID
         L     15,FF02ADDR         WRITE THE MESSAGE
         CALL  (15),MF=(E,MTPARML)
         B     EXIT
SORTUSER L     15,=V(QSORTL)       LOAD ADDRESS OF QSORTL
         LA    2,SORTCOMP          LOAD ADDRESS OF COMPARE FUNCTION
         TM    SORTOPT,SORTASID    TEST IF SORT BY ASID
         JZ    *+L'*+4             BR IF NOT
         LA    2,SORTASIDC         LOAD ADDRESS OF COMPARE FUNCTION
         CALL  (15),(USERLIST,=A(AUNEXT-AUSER),(2)),  SORT THE        ->
               MF=(E,SORTPARM)                         USER LIST
         MVC   MTMSGID,=C'MS01'    COPY THE MSGID FOR THE HEADER
         L     15,FF02ADDR         WRITE THE HEADER
         CALL  (15),MF=(E,MTPARML)
         LA    8,OUTLINE           LOAD ADDR OF OUR WORKING OUTPUT LINE
LISTUSER ICM   3,B'1111',USERLIST  LOAD ADDR OF THE NEXT USER
         BZ    LASTLINE            BR IF ALL USERS LISTED
         LA    0,AUUSER-AUSER(,3)         FIND THE END OF THE USERID
         LA    1,AUUSER-AUSER+L'AUUSER(,3)
         TRT   AUUSER-AUSER(,3),TRTTAB
         SR    1,0                 COMPUTE THE LENGTH OF THE USERID
         BNP   SKIPUSER            BR IF PROBLEM
         LR    9,1                 COPY THE LENGTH TO REG 9
         LA    0,FMTWORK           LOAD ADDR OF THE MINIFMT WORK AREA
         LA    1,FMT01             LOAD ADDR OF THE FORMAT
         TM    SORTOPT,ASID        TEST IF ASID OPTION
         JO    *+L'*+4             BR IF SO
         LA    1,FMT02             USE THE ALTERNATE FORMAT
         L     15,=V(MINIFMT)      LOAD ADDR OF MINIFMT
         CALL  (15)                CALL MINIFMT TO FORMAT UUU(X'HHHH')
         LH    9,0(,1)             LOAD THE MSG LENGHT
         AHI   9,-4                SUBTRACT THE SIZE OF THE RDW
         LA    15,0(9,8)           COMPUTE THE TRIAL END OF THE       ->
                                    USERID IN THE LINE
         LA    2,OUTLINEE          LOAD THE END OF THE LINE
         CR    15,2                TEST IF THE USERID WILL FIT
         BNH   COPYUSER            BR IF THE USERID WILL FIT
         LR    2,1                 SAVE ADDRESS OF THE USER DATA
         LA    14,OUTLINE          WRITE THE DATA LINE
         SR    8,14                COMPUTE THE LENGTH
         ST    8,MTINSRTS          STORE THE LENGTH AND
         ST    14,MTINSRTS+4        ADDRESS IN MTINSRTS
         MVC   MTMSGID,=C'DATA'    SET THE MESSAGE ID
         OI    MTSW1,MTNOIDSW      INDICATE THE MSG IS A DATA MESSAGE
         L     15,FF02ADDR         LOAD ADDRESS OF IKJEFF02
         CALL  (15),MF=(E,MTPARML) WRITE A USER LINE
         LR    1,2                 RESTORE ADDRESS OF THE USER DATA
         LA    8,OUTLINE           RELOAD THE START OF THE LINE
COPYUSER LA    0,4(,1)             COMPUTE ADDRESS OF UUU(X'HHHH')
         LR    1,9                 COPY THE LENGTH TO REG 1
         MVCL  8,0                 COPY UUUU(X'HHHH') TO THE OUTPUT
SKIPUSER LA    0,AUSIZE            FREE THE AUSER
         MVC   USERLIST,AUNEXT-AUSER(3)
         FREEMAIN RU,LV=(0),A=(3)
         B     LISTUSER            GO DO THE NEXT AUSER
LASTLINE LA    14,OUTLINE          WRITE THE LAST LINE
         SR    8,14                COMPUTE THE LENGTH
         BNP   EXIT                QUIT IF ERROR
         ST    8,MTINSRTS          STORE THE LENGTH AND
         ST    14,MTINSRTS+4        ADDRESS IN MTINSRTS
         OI    MTSW1,MTNOIDSW
         MVC   MTMSGID,=C'DATA'
         L     15,FF02ADDR
         CALL  (15),MF=(E,MTPARML)
EXIT     L     13,4(,13)           LOAD ADDR OF THE HIGHER SAVE AREA
         LHI   0,WASIZE            FREE THE WORK AREA
         FREEMAIN RU,LV=(0),A=(11)
         RETURN (14,12),T,RC=0     RESTORE REGISTERS & RETURN
         SPACE 1
CALLPARS LINK  SF=L,EP=IKJPARS
         EJECT
* QSORTL COMPARE FUNCTIONS
         CNOP  0,8
L        USING AUSER,14
R        USING AUSER,1
SORTASIDC SAVE  14                 SAVE REG 14
         LM    14,15,0(1)          LOAD THE PARAMETER LIST
         L     14,0(,14)           LOAD AUSER ADDRESSES FROM THE
         L     1,0(,15)             PARAMETER LIST
         LA    15,1                SET AN INITIAL RETURN CODE
         LH    0,L.AUASID          LOAD AN ASID
         CH    0,R.AUASID          COMPARE ASID W/ THE OTHER ASID
         JH    SC0300
         JL    SC0200
         J     SC0000
         CNOP  0,8
SORTCOMP SAVE  14                  SAVE REG 14
         LM    14,15,0(1)          LOAD THE PARAMETER LIST
         L     14,0(,14)           LOAD AUSER ADDRESSES FROM THE
         L     1,0(,15)             PARAMETER LIST
         LA    15,1                SET AN INITIAL RETURN CODE
SC0000   CLC   L.AUUSER,R.AUUSER   COMPARE THE USERIDS
         JH    SC0300
         JL    SC0200
SC0100   SR    15,15               SET RC = 0
         J     SC0300
SC0200   LNR   15,15               SET RC = -1
SC0300   RETURN 14,RC=(15)         RESTORE REG 14 & RETURN
         SPACE 1
         DROP  L,R                 KILL USING
         SPACE 1
         USING AUSER,3
         USING SA,13
FMT01    DC    AL1(1),C' '
         DC    AL.2(3),AL.6(3),AL1(0,0),SL2(SAREG09+3)
         DC    AL.2(3),AL.6(0),AL1(0,0),SL2(AUUSER)
         DC    AL1(L'FMT01B)
FMT01B   DC    C'(X'''
         DC    AL.2(3),AL.6(2),AL1(L'AUASID,0),SL2(AUASID)
         DC    AL1(L'FMT01C)
FMT01C   DC    C''')',X'FF'
         SPACE 1
FMT02    DC    AL1(1),C' '
         DC    AL.2(3),AL.6(3),AL1(0,0),SL2(SAREG09+3)
         DC    AL.2(3),AL.6(0),AL1(0,0),SL2(AUUSER)
         DC    X'FF'
         DROP  3,13
         DC    0D'0'
* TRANSLATE AND TEST TABLE TO LOCATE THE END OF A USERID.  THE TABLE
* IS ARRANGED SO THE TRT INSTRUCTION WILL STOP ON ANY EBCDIC
* "CONTROL" CHARACTER OR BLANK.
TRTTAB   DC    0XL256'0',(C' '+1)X'04',(256-(*-TRTTAB))X'00'
         LTORG ,
         DC    0D'0'
         SPACE 5
* MESSAGE SKELETONS FOR IKJEFF02
LISTTSOM RSECT
LISTTSOM RMODE ANY
         IKJTSMSG ('LTSU001I THE FOLLOWING TSO USERS ARE CURRENTLY ACTI>
               VE -'),MS01
         IKJTSMSG ('LTSU002I NO TSO USERS ARE PRESENTLY ACTIVE'),MS02
         IKJTSMSG ('LTSU003I LISTTSOU VERSION 1 LEVEL 0 ASSEMBLED ON &S>
               YSDATE AT &SYSTIME'),MS03
         IKJTSMSG (,' '),DATA
         IKJTSMSG ,
         DC    0D'0'
LISTTSOD CSECT
LISTTSOD RMODE 31
         PUSH  PRINT
         PRINT NOGEN
LISTTSOP IKJPARM DSECT=P           DEFINE IKJPARS PCL AND PDL
PSORT    IKJKEYWD DEFAULT='SORT(USERID)'
         IKJNAME SORT,SUBFLD=PSORTSBF
PVER     IKJKEYWD
         IKJNAME VERSION
PASID    IKJKEYWD
         IKJNAME ASID
PSORTSBF IKJSUBF
PSORTOPT IKJKEYWD
         IKJNAME USERID
         IKJNAME ASID
         IKJENDP
LISTTSOP CSECT
LISTTSOP RMODE ANY
         DC    0D'0'
         POP   PRINT
         END   LISTTSOU
MINIFMT  TITLE '                                  MINIFMT - A Message G>
               enerator'
***********************************************************************
*                                                                     *
* Title -- MINIFMT                                                    *
*                                                                     *
* Function / Operation -- MINIFMT is a message generator program.  It *
*   is a proper superset of MICROFMT; all valid MICROFMT formats will *
*   produce the same results as MICROFMT.  Additional formatting      *
*   includes date and time formats, formats to translate the record   *
*   formats included with the DCB and Format 1 DSCBs, the DSORG in    *
*   the DCB and Format 1 DSCBs, and tabs and multiple space inserts.  *
*                                                                     *
* Status / Change Level --                                            *
*   V1L5 -- September 2016                                            *
*    - CNVTBIN rewritten to improve performance and reduce storage    *
*      foot print                                                     *
*      - Fewer registers saved / restored                             *
*      - One divide / multiply pair eliminated                        *
*      - Last multiply of hours by 1,000,000 changed to               *
*        two MHI reg,1000 to eliminate a SR and the storage for       *
*        F'1000000'.                                                  *
*      - Method to strip the packed decimal sign from the result      *
*        simplified.                                                  *
*    - Copyright added to SAVE macro                                  *
*   V1L4 -- January 2015                                              *
*    - Added LJUSTX external function to left justify the contents    *
*      of a text data srea.                                           *
*   V1L3 -- November 2014                                             *
*    - Add formst 10, a binary to decimal conversion that inserts ,   *
*      characters between every 3 digits, e.g., 1,035 rather than     *
*      1035, to make large numbers easier to read.                    *
*   V1L2 -- June 2010                                                 *
*    - Hex conversion for fields containing more than 7 bytes not     *
*      being done correctly                                           *
*   V1L1 -- June 2010                                                 *
*    - Blank not being inserted between the date and time for format  *
*      codes 4 and 5 if both a date code and time code are specified  *
*    - Tab problem                                                    *
*   V1L0 -- April 2010                                                *
*                                                                     *
* Calling sequence --                                                 *
*            LA    0,FMTWORK                                          *
*            LA    1,FORMAT                                           *
*            L     15,=V(MINIFMT)      MINIFMT CAN ALSO BE CALLED     *
*            BALR  14,15               USING BRAS OR BRASL            *
*            ...                                                      *
*   FMTWORK  DC    XL200'0'                                           *
*   FORMAT   DC    -- Format Specifications --                        *
*                                                                     *
*   Returns -- Address of generated output line in register 1.        *
*     All other registers are returned unchanged                      *
*                                                                     *
* Format Specification --                                             *
*   A format consists of two or more field specifications.  There are *
*   three types of field specifications --                            *
*   - End of format -- X'FF' or X'00'                                 *
*   - In line text -- AL1(length),C'in line text'                     *
*     Length can be 1 to 127                                          *
*   - Data conversion -- These data conversions are provided.         *
*     . Character, for data areas from 1 to 255 bytes.                *
*     . Binary to decimal, of unsigned 1, 2 and 3 byte fields, and    *
*       signed 4 byte fields                                          *
*     . Binary to hexadecimal, of data areas from 1 to 255 bytes. Two *
*       output bytes for each input byte                              *
*     . Insert blanks.                                                *
*     . Format system date and time                                   *
*     . Format date and time using a TIME DEC formatted date and      *
*       time.                                                         *
*     . Provide a tabbing capability                                  *
*     Each data conversion is specified as a multiple byte format --  *
*     Offset  Bit  Value Purpose                                      *
*        0     0     1 -- Indicates data conversion                   *
*        0     1     0 -- Address specified as an in-line 4 byte      *
*                         address constant                            *
*        0     1     1 -- Address specified as a 2 byte S type        *
*                         address                                     *
*                         The S-con base register can be registers 2  *
*                         through 13.  Since registers 14, 15, 0 and  *
*                         are used as link registers, their use in    *
*                         an S-con is limited.                        *
*        0    2-7    0 -- Copy text string to output line             *
*                    1 -- Translate 1 to 4 byte binary to decimal     *
*                    2 -- Translate 1 to 255 byte binary to           *
*                         hexadecimal digits                          *
*                    3 -- Provide input length for an undefined       *
*                         text or  hexadecimal conversion             *
*                    4 -- Format the system date and time.  The       *
*                         input length byte specifies the date        *
*                         format, the output length byte specifies    *
*                         the time format.  MINIFMT obtains the       *
*                         system date the first time this format is   *
*                         encountered.                                *
*                    5 -- Format the date and time in a TIME DEC      *
*                         storage area                                *
*                    6 -- Insert blanks                               *
*                    7 -- Tab.  A tab to a position higher than the   *
*                         current end of line inserts blanks.  The    *
*                         position is relative to the first byte in   *
*                         the line.                                   *
*                    8 -- Translate DCBRECFM/DS1RECFM                 *
*                    9 -- Translate DCBDSORG/DS1DSORG                 *
*                   10 -- Tranalate 1 to 4 byte binary to decimal     *
*                         using an alternate format, nnn,nnn rather   *
*                         than nnnnnn                                 *
*        1    0-7    Input length.                                    *
*                    For codes 4 and 5, this byte contains a date     *
*                    format code --                                   *
*                     1 -- yyyy/mm/dd                                 *
*                     2 -- yy/mm/dd                                   *
*                     3 -- mm/dd/yyyy                                 *
*                     4 -- mm/dd/yy                                   *
*                     5 -- yyyy month dd                              *
*                     6 -- yy month dd                                *
*                     7 -- month dd, yyyy                             *
*                     8 -- yyyy                                       *
*                     9 -- yy                                         *
*                    10 -- mm    (Month as a two digit number)        *
*                    11 -- mmm   (Abbreviated month name)             *
*                    12 -- month (Full month name)                    *
*                    13 -- dd    (Day of month)                       *
*                    14 -- ddd   (Day of year)                        *
*                                                                     *
*                    Date codes that insert a 2 digit year makes      *
*                    your program Y2K conpatible if it is Y2K         *
*                    compliant in all other aspects                   *
*                                                                     *
*        2    0-7    Output length.  Not used for hex conversion.  If *
*                    0 is specified, for binary to decimal conversion *
*                    the output length is the length of the converted *
*                    number, for character conversion the output      *
*                    length is the input length with trailing blanks  *
*                    removed                                          *
*                                                                     *
*                    For codes 4 and 5, this byte contains a time     *
*                    format code --                                   *
*                     1 -- hh:mm       (24 hour clock)                *
*                     2 -- hh:mm xM    (xM is AM or PM)               *
*                     3 -- hh:mm:ss    (24 hour clock)                *
*                     4 -- hh:mm:ss xM (xM is AM or PM)               *
*                                                                     *
*                    If a date code and a time code are both          *
*                    present, a blank appears between the date and    *
*                    time.                                            *
*                                                                     *
*        3           Data address, as either a 2-bye S type address   *
*                    or a 4 byte address constant.                    *
*                                                                     *
* Attributes -- MINIFMT is reenterable, refreshable and reusable.  It *
*   operates in any key, problem or supervisor state.  It is  not     *
*   intended to operate in AR mode or the 64-bit addressing mode.  It *
*   will operate in the 24-bit addressing mode if the format, work    *
*   area, and any data referenced in the format is in the 24-bit      *
*   residence area.                                                   *
*                                                                     *
***********************************************************************
         SPACE 5
MINIFMT  RSECT
MINIFMT  AMODE ANY
MINIFMT  RMODE ANY
         PUSH  PRINT
         PRINT NOGEN
         DCBD  DSORG=QS,DEVD=DA    DEFINE DCB SYMBOLS
         POP   PRINT
MFMTWORK DSECT
MFMTWWRK DS    D                   DOUBLE WORD ALIGNED 8 BYTE WORK AREA
MFMTWDT  DS    2F                  SYSTEM DATE AND TIME
MFMTWEWK DS    0C' 999999999999999'
MFMTWLNG DS    C' 999,999,999,999,999'
MFMTWLEN DS    AL1                 LENGTH FROM FORMAT 3
MFMTWFLG DS    AL1                 NON-ZERO IF SYSTEM DATE AND TIME   ->
                                    STORED IN MFMFWDT
MFMTSAVE DS    AL1,0F
MFMTWLNE DS    2AL2                GENERATED OUTPUT LINE
MINIFMT  RSECT
         BASR  15,0                STORE CURRENT ADDRESS IN REG 15
         USING *,12                ESTABLISH PROGRAM BASE REGISTER
         USING MFMTWORK,11         ESTABLISH WORK AREA ADDRESSABILITY
*        SAVE  (14,12),,MINIFMT-V1L4-&SYSDATE-&SYSTIME  SAVE REGISTERS
         SAVE  (14,12),,'MINIFMT V1L5 &SYSDATE &SYSTIME  Copyright (c) >
               2010, 2014-2016 J. Stephen Myers'
         LR    12,15               COPY ENTRY POINT ADDRESS TO REG 12
         LR    11,0                COPY WORK AREA ADDRESS TO REG 11
         MVI   MFMTWFLG,0          INDICATE SYSTEM DATE AND TIME NOT  ->
                                    IN WORKAREA
         LR    3,1                 COPY ADDRESS OF FORMAT TO REG 3
         LA    14,MFMTWLNE+4       LOAD START OF TEXT OUTPUT
MFMT0100 CLI   0(3),X'FF'          TEST IF END OF FORMAT
         JE    MFMT7600
         CLI   0(3),0
         JE    MFMT7600
         TM    0(3),X'80'          TEST IF DATA CONVERSION
         JO    MFMT0200            BR IF SO
         SR    15,15               SET REG 15 = 0
         IC    15,0(,3)            LOAD LENGTH OF IN-LINE CHARACTER   ->
                                    STRING
         LA    0,1(,3)             LOAD START OF IN-LINE CHARACTER    ->
                                    STRING
         LR    1,15                COPY LENGTH TO REG 1
         MVCL  14,0                COPY IN-LINE CHARACTER STRING TO   ->
                                    NEW LINE
         LR    3,0                 COPY START OF NEXT FORMAT TO REG 3
         J     MFMT0100            GO CHECK THE NEXT FORMAT
MFMT0200 IC    15,0(,3)            LOAD FORMAT TYPE
         N     15,=A(X'3F')        ISOLATE TYPE
         CHI   15,10               COMPARE WITH MAX
         JH    MFMT7500            BR TO FORMAT ERROR
         SLL   15,2                MULTIPLY TYPE BY 4
         B     *+4(15)             BR TO JUMP TABLE ENTRY
         J     MFMT0400            TYPE 0 - CHARACTER
         J     MFMT0800            TYPE 1 - BINARY TO DECIMAL
         J     MFMT1200            TYPE 2 -BINARY TO HEXADECIMAL DIGITS
         J     MFMT0300            TYPE 3 - SAVE LENGTH FOR TYPES 0 & 2
         J     MFMT1700            TYPE 4 - FORMAT SYSTEM DATE AND TIME
         J     MFMT1900            TYPE 5 - FORMAT DATE AND TIME
         J     MFMT6500            TYPE 6 - INSERT BLANKS
         J     MFMT7300            TYPE 7 - TAB
         J     MFMT6600            TYPE 8 - TRANSLATE DCBRECFM
         J     MFMT6900            TYPE 9 - TRANSLATE DCBDSORG
         J     MFMT0810            TYPE 10 - ALTERNATE TYPE 2
*        J     MFMT7500            TYPE 11 NOT SUPPORTED
*        J     MFMT7500            TYPE 12 NOT SUPPORTED
*        J     MFMT7500            TYPE 13 NOT SUPPORTED
*        J     MFMT7500            TYPE 14 NOT SUPPORTED
*        J     MFMT7500            TYPE 15 NOT SUPPORTED
MFMT0300 LA    1,3(,3)             LOAD ADDRESS OF DATA ADDRESS
         BRAS  15,MFMT5900         GET THE ADDRESS
         MVC   MFMTWLEN,0(4)       SAVE THE LENGTH
         J     MFMT0100            GO DO THE NEXT FORMAT
MFMT0400 LA    1,3(,3)             LOAD ADDRESS OF DATA ADDRESS
         SR    5,5                 SET REG 5 = 0
         SR    6,6                 SET REG 6 = 0
         ICM   5,B'0001',1(3)      LOAD THE INPUT LENGTH
         JNZ   *+L'*+4             BR IF INPUT LENGTH IS DEFINED
         IC    5,MFMTWLEN          LOAD SAVED LENGTH
         IC    6,2(,3)             LOAD THE OUTPUT LENGTH
         BRAS  15,MFMT5900         GET THE ADDRESS
         LTR   15,6                TEST IF OUTPUT LENGTH IS SPECIFIED
         JZ    MFMT0500            BR IF NOT
         LR    0,4                 COPY START OF DATA TO REG 0
         LR    1,5                 COPY INPUT LENGTH TO REG 1
*        ICM   1,B'1000',=C' '     LOAD FILL CHARACTER
         O     1,=AL1(C' ',0,0,0)  ADD FILL CHARACTER
         MVCL  14,0                COPY DATA TO OUTPUT AREA
         J     MFMT0100            GO DO THE NEXT FORMAT
MFMT0500 LA    15,0(5,4)           PUT END OF INPUT AREA INTO REG 15
MFMT0600 AHI   15,-1               BACKUP 1 BYTE
         CR    15,4                TEST IF START OF DATA
         JE    MFMT0700            BR IF SO
         CLI   0(15),C' '          TEST IF TRAILING BLANK
         JE    MFMT0600            BR IF SO
MFMT0700 LA    1,1(,15)            SET REG 1 TO END OF INPUT
         SR    1,4                 COMPUTE ACTUAL INPUT LENGTH
         LR    0,4                 COPY START OF INPUT TO REG 0
         LR    15,1                COPY LENGTH TO REG 15
         MVCL  14,0                COPY TEXT TO OUTPUT LINE
         J     MFMT0100            GO DO THE NEXT FORMAT
MFMT0800 DC    0H'0'
MFMT0810 MVC   MFMTSAVE,0(3)       SAVE THE ENTRY CODE
         NI    MFMTSAVE,X'3F'      DISCARD THE 2 HIGH ORDER BITS
         LA    1,3(,3)             LOAD ADDRESS OF DATA ADDRESS
         SR    5,5                 SET REG 5 = 0
         SR    6,6                 SET REG 6 = 0
         IC    5,1(,3)             LOAD THE INPUT LENGTH
         IC    6,2(,3)             LOAD THE OUTPUT LENGTH
         BRAS  15,MFMT5900         GET THE ADDRESS
         SLL   5,2                 MULTIPLY LENGTH BY 4
         SR    15,15               SET REG 15 = 0
         EX    0,MFMT6400(5)       LOAD THE BINARY VALUE
         CVD   15,MFMTWWRK         CONVERT MFMT0800 VALUE TO PACKED   ->
                                    DECIMAL
         CLI   MFMTSAVE,1          TEST FORMAT CODE
         JE    MFMT0820            BR IF FORMAT 1
         MVC   MFMTWLNG,MFMT8310   COPY THE ALTERNATE EDIT MASK
         LA    1,MFMTWLNG+L'MFMTWLNG-1  LOAD ADDR OF THE DEFAULT 0
         EDMK  MFMTWLNG,MFMTWWRK   EDIT THE NUMBER
         J     MFMT0830
MFMT0820 MVC   MFMTWEWK,MFMT8300   COPY EDIT MASK TO WORK AREA
         LA    1,MFMTWEWK+L'MFMTWEWK-1
         EDMK  MFMTWEWK,MFMTWWRK   CONVERT PACKED DECIMAL VALUE TO    ->
                                    DECIMAL DIGITS
MFMT0830 LTR   15,15               TEST VALUE
         JNM   MFMT0900            BR IF VALUE IS +
         AHI   1,-1                BACKUP START OF NUMBER BY 1
         MVI   0(1),C'-'           INSERT A MINUS SIGN
MFMT0900 LR    0,1                 COPY START OF VALUE TO REG 0
         LA    1,MFMTWEWK+L'MFMTWEWK  LOAD END OF VALUE
         CLI   MFMTSAVE,1          ALTERNATE FORMAT?
         JE    *+L'*+4             BR IF NOT
         LA    1,MFMTWLNG+L'MFMTWLNG  LOAD ALTERNATE END
         SR    1,0                 COMPUTE LENGTH OF NUMBER
         LTR   6,6                 TEST OUTPUT LENGTH
         JZ    MFMT1100            BR IF 0
         CR    6,1                 COMPARE OUTPUT LENGTH WITH MAX
         JNL   MFMT1000            BR IF NUMBER WILL FIT IN FIELD
         LR    15,6                COPY LENGTH TO REG 15
         L     1,=AL1(C'*',0,0,0)  LOAD FILL CHARACTER
         MVCL  14,0                INSERT *S IN THE OUTPUT FIELD
         J     MFMT0100            GO DO THE NEXT FORMAT
MFMT1000 LR    5,14                SAVE ADDRESS OF OUTPUT
         L     7,=AL1(C' ',0,0,0)  LOAD FILL CHARACTER
         LR    15,6                COPY FIELD LENGTH TO REG 15
         MVCL  14,6                CLEAR THE OUTPUT FIELD
         LR    14,5                COPY START OF OUTPUT FIELD TO REG 14
         LR    15,6                COPY OUTPUT FIELD LENGTH TO REG 15
         SR    15,1                COMPUTE NUMBER OF LEADING BLANKS
         AR    14,15               COMPUTE START OF NUMBER IN OUTPUT
MFMT1100 LR    15,1                COPY LENGTH TO REG 15
         MVCL  14,0                COPY CONVERTED VALUE TO OUTPUT
         J     MFMT0100            GO DO THE NEXT FORMAT
* TRANSLATE INPUT BINARY DATA TO HEXADECIMAL DIGITS
* JUST THE INPUT LENGTH IS USED, AN OUTPUT LENGTH IS IGNORED
MFMT1200 LA    1,3(,3)             LOAD ADDRESS OF ADDRESS
         SR    5,5                 SET REG 5 = 0
         ICM   5,B'0001',1(3)      LOAD THE INPUT LENGTH
         JNZ   *+L'*+4             BR IF INPUT LENGTH IS DEFINED
         IC    5,MFMTWLEN          LOAD SAVED INPUT LENGTH
         BRAS  15,MFMT5900         GET THE ADDRESS
MFMT1300 CHI   5,7                 TEST REMINING LENGTH
         JNH   MFMT1400            BR IF 7 OR FEWER BYTES REMAIN
         UNPK  0(15,14),0(8,4)     TRANSLATE 7 BYTES TO HEX DIGITS
         TR    0(14,14),MFMT8200
         AHI   14,14               BUMP THE OUTPUT POINTER
         AHI   4,7                 BUMP THE INPUT POINTER
         AHI   5,-7                REDUCE REMAINING LENGTH BY 7
         J     MFMT1300            GO DO THE NEXT GROUP
MFMT1400 LR    1,5                 COPY REMAINING LENGTH TO REG 1
         SLL   1,5                 GET OUTPUT LENGTH
         OR    1,5                 ADD IN INPUT LENGTH
         EX    1,MFMT1500          TRANSLATE LAST GROUP OF BYTES
         SRL   1,4                  TO HEXADECIMAL DIGITS
         EX    1,MFMT1600
         AR    14,1                UPDATE THE OUTPUT POINTER
         J     MFMT0100            GO CHECK THE NEXT FORMAT
MFMT1500 UNPK  0(*-*,14),0(*-*,4)  ** EXECUTE ONLY **
MFMT1600 TR    0(*-*,14),MFMT8200  ** EXECUTE ONLY **
* FORMAT SYSTEM DATE AND TIME
MFMT1700 CLI   MFMTWFLG,0          TEST IF SYSTEM TIME OBTAINED
         JNE   MFMT1800            BR IF SO
         ST    14,MFMTWDT          SAVE REG 14
         TIME  DEC                 GET THE SYSTEM DATE AND TIME
         L     14,MFMTWDT          RESTORE REG 14
         STM   0,1,MFMTWDT         STORE THE DATE AND TIME
         MVI   MFMTWFLG,255        INDICATE DATE AND TIME IN WORK AREA
MFMT1800 SR    5,5                 SET REG 5 = 0
         SR    6,6                 SET REG 6 = 0
         IC    5,1(,3)             LOAD THE DATE CODE
         IC    6,2(,3)             LOAD THE TIME CODE
         LA    3,3(,3)             LOAD ADDRESS OF THE NEXT FORMAT
         LA    4,MFMTWDT           LOAD ADDRESS OF THE DATE AND TIME
         J     MFMT2000            BR TO DATE/TIME COMMON CODE
* FORMAT DATE AND TIME FROM STORAGE REPRESENTING REG 0 AND REG 1
* AFTER EXECUTING A TIME DEC MACRO
MFMT1900 SR    5,5                 SET REG 5 = 0
         SR    6,6                 SET REG 6 = 0
         IC    5,1(,3)             LOAD THE DATE CODE
         IC    6,2(,3)             LOAD THE TIME CODE
         LA    1,3(,3)             LOAD THE ADDRESS OF THE ADDRESS
         BRAS  15,MFMT5900         GET THE DATA AREA ADDRESS
MFMT2000 LTR   5,5                 TEST IF DATE WANTED
         JZ    MFMT5010            BR IF NOT
         ICM   9,B'1111',4(4)      LOAD THE DATE
         JNZ   MFMT2010            BR IF DATE IS PRSENT
         SR    1,1                 SET DAY OF MONTH = 0
         SR    8,8                 SET MONTH = 0
         MVC   MFMTWEWK+L'MFMTWEWK-3-4(4),=C'0000' SET YEAR IN MFMTWEWK
         J     MFMT2210            AND CONTINUE
MFMT2010 ZAP   MFMTWWRK,4(4,4)     COPY THE DATE TO THE WORK AREA
         CVB   9,MFMTWWRK          CONVERT THE DATE TO BINARY
         A     9,=F'1900000'       CONVERT THE YEAR FROM CYY TO A     ->
                                    TRUE YEAR
         CVD   9,MFMTWWRK          CONVERT YYYYDDD TO PACKED DECIMAL
         UNPK  MFMTWEWK,MFMTWWRK   CONVERT YYYYDDD TO DECIMAL.  THE   ->
                                    DDD IS NOT USABLE, BUT THE YYYY IS
         SR    8,8                 SET REG 8 = 0
         D     8,=F'1000'          ISOLATE THE YEAR
         LR    1,8                 COPY THE DAY OF YEAR TO REG 1
         SR    8,8                 SET REG 8 = 0
         LR    0,9                 COPY YEAR TO REG 0
         N     0,=A(B'11')         TEST IF YEAR DIVISIBLE BY 4
         JNZ   MFMT2100            BR IF NOT, IT CAN'T BE A LEAP YEAR
         D     8,=F'100'           DIVIDE YEAR BY 100
         LTR   8,8                 TEST REMAINDER
         JNZ   MFMT2200            YEAR IS NOT A CENTURY YEAR, SO IT  ->
                                    MUST BE A LEAP YEAR
         N     9,=A(B'11')         TEST IF YEAR CAN BE DIVIDED BY 400
         JZ    MFMT2200            CENTURY YEAR IS A LEAP YEAR
MFMT2100 CHI   1,31+28             COMPARE DAY OF YEAR WITH FEB 28
         JNH   MFMT2200            BR IF DAY OF YEAR DOES NOT HAVE    ->
                                    TO BE ADJUSTED
         AHI   1,1                 PRETEND DAY OF YEAR IS IN A LEAP   ->
                                    YEAR
MFMT2200 SR    8,8                 SET REG 8 = 0
         IC    8,MFMT8600(1)       LOAD THE MONTH FOR THE DAY OF YEAR
         SLL   8,1                 MULTIPLY MONTH BY 2
         SH    1,MFMT8500(8)       SUBTRACT DAY OF YEAR FOR THE 1ST   ->
                                    DAY OF THE MONTH FROM DAY OF YEAR
         SRL   8,1                 RESET MONTH TO "NORMAL" FORM
* DAY OF MONTH IS IN REG 1, MONTH IS IN REG 8, AND YEAR IN
* CHARACTER FORM IS IN MFMTWEWK
MFMT2210 SLL   5,2                 MULTIPLY DATE CODE BY 4
         B     *(5)                BR
         J     MFMT2300             1 -- FORMAT DATE AS YYYY/MM/DD
         J     MFMT2400             2 -- FORMAT DATE AS YY/MM/DD
         J     MFMT2600             3 -- FORMAT DATE AS MM/DD/YYYY
         J     MFMT2700             4 -- FORMAT DATE AS MM/DD/YY
         J     MFMT2900             5 -- FORMAT DATE AS YYYY MONTH DD
         J     MFMT3000             6 -- FORMAT DATE AS YY MONTH DD
         J     MFMT3200             7 -- FORMAT DATE AS MONTH DD, YYYY
         J     MFMT3300             8 -- FORMAT YEAR AS YYYY
         J     MFMT3400             9 -- FORMAT YEAR AS YY
         J     MFMT3500            10 -- FORMAT MONTH AS MM (NUMERIC)
         J     MFMT3600            11 -- FORMAT MONTH AS MMM
         J     MFMT3700            12 -- FORMAT MONTH AS MONTH
         J     MFMT3710            13 -- FORMAT DAY OF MONTH AS DD
         J     MFMT3720            14 -- FORMAT DAY OF YEAR
         J     MFMT7500            15 -- INVALID
MFMT2300 ICM   15,B'1111',4(4)     LOAD THE DATE
         JNZ   MFMT2310            BR IF DATE PRESENT
         MVC   0(10,14),=CL10'--'  INDICATE MISSING DATE
         AHI   14,10               BUMP OUTPUT
         J     MFMT5000            TEST IF TIME
MFMT2310 BRAS  15,MFMT3800         COPY THE 4 DIGIT YEAR
         J     MFMT2500            AND CONTINUE
MFMT2400 ICM   15,B'1111',4(4)     LOAD THE DATE
         JNZ   MFMT2410            BR IF DATE PRESENT
         MVC   0(8,14),=CL10'--'   INDICATE MISSING DATE
         AHI   14,8                BUMP OUTPUT
         J     MFMT5000            TEST IF TIME
MFMT2410 BRAS  15,MFMT3900         COPY THE 2 DIGIT YEAR
MFMT2500 BRAS  15,MFMT4000         INSERT A /
         BRAS  15,MFMT4300         INSERT MM
         BRAS  15,MFMT4000         INSERT A /
         BRAS  15,MFMT4800         INSERT DD
         J     MFMT5000            TEST IF TIME
MFMT2600 ICM   15,B'1111',4(4)     LOAD THE DATE
         JNZ   MFMT2610            BR IF DATE PRESENT
         MVC   0(10,4),=CL10'--'   INDICATE MISSING DATE
         AHI   14,10               BUMP OUTPUT
         J     MFMT5000            TEST IF TIME
MFMT2610 BRAS  15,MFMT4300         INSERT MM
         BRAS  15,MFMT4000         INSERT A /
         BRAS  15,MFMT4800         INSERT DD
         BRAS  15,MFMT4000         INSERT A /
         BRAS  15,MFMT3800         INSERT YYYY
         J     MFMT5000            TEST IF TIME
MFMT2700 ICM   15,B'1111',4(4)     LOAD THE DATE
         JNZ   MFMT2710            BR IF DATE PRESENT
         MVC   0(8,14),=CL10'--'   INDICATE MISSING DATE
         AHI   14,8                BUMP OUTPUT
         J     MFMT5000            TEST IF TIME
MFMT2710 BRAS  15,MFMT4300         INSERT MM
         BRAS  15,MFMT4000         INSERT A /
         BRAS  15,MFMT4800         INSERT DD
         BRAS  15,MFMT4000         INSERT A /
         BRAS  15,MFMT3900         INSERT YY
         J     MFMT5000            TEST IF TIME
MFMT2800 NOPR  0                   ** NOT USED! **
MFMT2900 ICM   15,B'1111',4(4)     LOAD THE DATE
         JNZ   MFMT2910            BR IF DATE PRESENT
         MVC   0(10,4),=CL10'--'   INDICATE MISSING DATE
         AHI   14,10               BUMP OUTPUT
         J     MFMT5000            TEST IF TIME
MFMT2910 BRAS  15,MFMT3800         INSERT YYYY
         J     MFMT3100
MFMT3000 BRAS  15,MFMT3900         INSERT YY
MFMT3100 BRAS  15,MFMT4100         INSERT A SPACE
         BRAS  15,MFMT4400         INSERT LONG MONTH
         BRAS  15,MFMT4100         INSERT A SPACE
         BRAS  15,MFMT4800         INSERT DD
         J     MFMT5000            TEST IF TIME
* FORMAT MONTH DD, YYYY
MFMT3200 BRAS  15,MFMT4400         INSERT A LONG MONTH
         BRAS  15,MFMT4100         INSERT A SPACE
         BRAS  15,MFMT4800         INSERT DD
         BRAS  15,MFMT4210         INSERT C', '
         BRAS  15,MFMT3800         INSERT YYYY
         J     MFMT5000            TEST IF TIME
* FORMAT YYYY
MFMT3300 BRAS  15,MFMT3800         INSERT YYYY
         J     MFMT5000            TEST IF TIME
* FORMAT YY
MFMT3400 BRAS  15,MFMT3900         INSERT YY
         J     MFMT5000            TEST IF TIME
* FORMAT MM (NUMERIC MONTH)
MFMT3500 BRAS  15,MFMT4300         INSERT MM
         J     MFMT5000            TEST IF TIME
* FORMAT MMM (ABBREVIATED MONTH)
MFMT3600 BRAS  15,MFMT4700         INSERT MMM
         J     MFMT5000            TEST IF TIME
* INSERT FULL MONTH NAME
MFMT3700 BRAS  15,MFMT4400
         J     MFMT5000            TEST IF TIME
* INSERT DD
MFMT3710 BRAS  15,MFMT4800         INSERT DD
         J     MFMT5000            TEST IF TIME
* INSERT DDD (DAY OF YEAR)
MFMT3720 UNPK  MFMTWWRK,4(4,4)     CONVERT 0CYYDDD TO DECIMAL
         OI    MFMTWWRK+7,X'F0'    MAKE SURE THE LAST BYTE IS A DIGIT
         MVC   0(3,14),MFMTWWRK+5  COPY DDD TO OUTPUT
         AHI   14,3                UPDATE THE OUTPUT POINTER
         J     MFMT5000            TEST IF TIME
* GET THE 4 DIGIT YEAR
MFMT3800 MVC   0(4,14),MFMTWEWK+L'MFMTWEWK-3-4  COPY THE YEAR
         AHI   14,4                BUMP THE OUTPUT POINTER
         BR    15                  AND RETURN
* GET THE 2 DIGIT YEAR
MFMT3900 MVC   0(2,14),MFMTWEWK+L'MFMTWEWK-3-2  COPY THE YEAR
         AHI   14,2                BUMP THE OUTPUT POINTER
         BR    15                  AND RETURN
* INSERT A /
MFMT4000 MVI   0(14),C'/'          INSERT A /
         J     MFMT4200            UPDATE POSITION AND RETURM
* INSERT A SPACE
MFMT4100 MVI   0(14),C' '          INSERT A BLANK
MFMT4200 AHI   14,1                BUMP THE OUTPUT POINTER
         BR    15                  AND RETURN
* INSERT C', '
MFMT4210 MVC   0(2,14),=C', '      COPY C', ' TO OUTPUT
         AHI   14,2                UPDATE OUTPUT POINTER
         BR    15                  AND RETURN
* INSERT 2 DIGIT MONTH
MFMT4300 CVD   8,MFMTWWRK          CONVERT MONTH TO PACKED DECIMAL
         J     MFMT4900            CONTINUE
* INSERT FULL MONTH NAME
MFMT4400 LR    9,8                 COPY REG 8 TO REG 9
         MHI   9,9                 MULTIPLY MONTH BY LENGTH OF A MONTH
         LA    10,MFMT8700+9(9)    LOAD END OF MONTH NAME
         LA    9,MFMT8700(9)       LOAD START OF THE MONTH NAME
MFMT4500 BCTR  10,0                BACKUP 1 BYTE
         CLI   0(10),C' '          TEST FOR TRAILING BLANK
         JE    MFMT4500            BR IF TRAILING BLANK
         SR    10,9                COMPUTE LENGTH TO MOVE
         EX    10,MFMT4600         MOVE MONTH NAME TO OUTPUT LINE
         LA    14,1(10,14)         COMPUTE ADDRESS OF NEXT OUTPUT BYTE
         BR    15                  AND RETURN
MFMT4600 MVC   0(*-*,14),0(9)      ** EXECUTE ONLY **
* INSERT ABBREVIATED MONTH
MFMT4700 LR    9,8                 COPY REG 8 TO REG 9
         MHI   9,9                 MULTIPLY MONTH BY 9
         LA    9,MFMT8700(9)       COMPUTE ADDRESS OF MONTH NAME
         MVC   0(3,14),0(9)        COPY ABBREVIATED MONTH TO OUTPUT
         AHI   14,3                UPDATE OUTPUT POSITION
         BR    15                  AND RETURN
* INSERT DAY OF MONTH
MFMT4800 CVD   1,MFMTWWRK          CONVERT DAY OF MONTH TO PACKED DEC
MFMT4900 OI    MFMTWWRK+7,X'0F'    MAKE SURE THE LAST NIBBLE IS OK
         UNPK  0(2,14),MFMTWWRK    CONVERT VALUE TO DECIMAL
         AHI   14,2                BUMP THE OUTPUT POINTER
         BR    15                  AND RETURN
* TEST IF TIME WANTED
MFMT5000 LTR   6,6                 TEST TIME CODE
         JZ    MFMT0100            BR IF TIME NOT WANTED
         MVI   0(14),C' '          INSERT A BLANK
         AHI   14,1                BUMP THE OUTPUT POSITION
         J     MFMT5020
MFMT5010 LTR   6,6                 TEST TIME CODE
         JZ    MFMT0100            BR IF TIME NOT WANTED
MFMT5020 CHI   6,4                 TEST IF SUPPORTED
         JH    MFMT7500            BR IF NOT SUPPORTED
         SLL   6,2                 MULTIPLY TIME CODE BY 4
         B     *(6)                BR BASED ON TIME CODE
         J     MFMT5100             1 - HH:MM
         J     MFMT5200             2 - HH:MM AM (OR PM)
         J     MFMT5300             3 - HH:MM:SS
         J     MFMT5400             4 - HH:MM:SS AM (OR PM)
MFMT5100 MVC   MFMTWEWK(6),MFMT8400  COPY EDIT MASK TO OUTPUT
         ED    MFMTWEWK(6),0(4)    TRANSLATE PACKED DECIMAL DIGITS    ->
                                    TO DECIMAL
         MVC   0(5,14),MFMTWEWK+1  COPY TRANSLATED TIME TO OUTPUT
         AHI   14,5                BUMP THE OUTPUT POINTER
         J     MFMT0100            AND CONTINUE
MFMT5200 MVC   MFMTWEWK(6),MFMT8400  COPY EDIT MASK TO OUTPUT
         ED    MFMTWEWK(6),0(4)    TRANSLATE PACKED DECIMAL DIGITS    ->
                                    TO DECIMAL
         MVC   0(5,14),MFMTWEWK+1  COPY TRANSLATED TIME TO OUTPUT
         LA    15,5(,14)           SET REG 15
         J     MFMT5600
MFMT5300 MVC   MFMTWEWK,MFMT8400   COPY EDIT MASK TO WORK AREA
         ED    MFMTWEWK,0(4)       TRANSLATE PACKED DECIMAL DIGITS    ->
                                    TO DECIMAL
         MVC   0(L'MFMT8400-1,14),MFMTWEWK+1  COPY TRANSLATED TIME    ->
                                    TO OUTPUT
         AHI   14,L'MFMT8400-1     BUMP THE OUTPUT POINTER
         J     MFMT0100            GO DO THE NEXT FORMAT
MFMT5400 MVC   MFMTWEWK,MFMT8400   COPY EDIT MASK TO WORK AREA
         ED    MFMTWEWK,0(4)       TRANSLATE PACKED DECIMAL DIGITS    ->
                                    TO DECIMAL
         MVC   0(L'MFMT8400-1,14),MFMTWEWK+1  COPY TRANSLATED TIME    ->
                                    TO OUTPUT
         LA    15,L'MFMT8400-1(,14)  SET REG 15
MFMT5600 CLI   0(4),X'12'          COMPARE ORIGINAL TIME
         JNL   MFMT5700            BR IF PM
         MVC   0(3,15),=C' AM'     ADD AM TO OUTPUT
         CLI   0(4),X'00'          TEST IF 12 AM
         JNE   MFMT5800            BE IF NOT, WE'RE DONE
         MVC   0(2,14),=C'12'      CHANGE 00 TO 12
         J     MFMT5800            AND CONTINUE
MFMT5700 MVC   0(3,15),=C' PM'     INSERT PM
         CLI   0(4),X'12'          TEST IF NOON TO 12:59
         JE    MFMT5800            BR IF SO, TIME DOES NOT HAVE TO    ->
                                    ADJUSTED
         MVC   MFMTWWRK+4(4),0(4)  COPY ORIGINAL TIME TO WORK AREA
         OI    MFMTWWRK+7,X'0F'    SET A VALID SIGN
         SP    MFMTWWRK+4(4),=P'1200000'  ADJUST THE TIME
         MVC   MFMTWWRK(4),=X'402120'  COPY EDIT MASK
         ED    MFMTWWRK(4),MFMTWWRK+4  CONVERT ADJUSTED TIME TO DECIMAL
         MVC   0(2,14),MFMTWWRK+1  REPLACE HH WITH ADJUSTED HH
MFMT5800 LA    14,3(,15)           UPDATE OUTPUT POINTER
         J     MFMT0100            GO DO THE NEXT FORMAT
         CNOP  0,8
* GET THE ADDRESS.  REG 1 POINTS TO THE ADDRESS CONSTANT, REG 3
* POINTS TO THE FORMAT.  ON RETURN, REG 3 PONTS TO THE NEXT FORMAT,
* AND REG 4 CONTAINS THE OPERAND ADDRESS
MFMT5900 TM    0(3),X'40'          TEST IF S-TYPE ADDRESS
         JZ    MFMT6300            BR IF IN-LINE ADDRESS CONSTANT
MFMT6000 LH    2,0(,1)             LOAD OFFSET FROM THE BASE REGISTER
         N     2,=A(X'FFF')        ISOLATE THE OFFSET
         IC    4,0(,1)             LOAD REGISTER
         N     4,=A(X'F0')         ISOLATE THE REGISTER
         SRL   4,2                 TRANSLATE REGISTER VALUE TO WORD   ->
                                    OFFSET
         L     4,MFMT8100(4)       LOAD THE SAVE AREA OFFSET FOR THE  ->
                                    REGISTER
         CHI   4,99                TEST IF REG 13
         JNE   MFMT6100            BR IF NOT
         LR    4,13                COPY REG 13 TO REG 4
         J     MFMT6200            GO ADD THE OFFSET
MFMT6100 L     4,0(4,13)           LOAD THE BASE REGISTER FROM THE    ->
                                    SAVE AREA
MFMT6200 ALR   4,2                 ADD THE OFFSET TO THE BASE REGISTER
         LA    3,2(,1)             COMPUTE THE ADDRESS                ->
                                    OF THE NEXT FORMAT
         BR    15                  GO TO THE CONVERSION ROUTINE
MFMT6300 ICM   4,B'1111',0(1)      LOAD THE DATA ADDRESS
         LA    3,4(,1)             LOAD ADDRESS OF THE NEXT FORMAT
         BR    15                  GO TO THE CONVERSION ROUTINE
MFMT6400 J     MFMT7500            LENGTH 0, FORMAT ERROR
         IC    15,0(,4)            LENGTH 1, LOAD 1 BYTE
         ICM   15,B'0011',0(4)     LENGTH 2, LOAD 2 BYTES
         ICM   15,B'0111',0(4)     LENGTH 3, LOAD 3 BYTES
         ICM   15,B'1111',0(4)     LENGTH 4, LOAD 4 BYTES
MFMT6500 SR    15,15               SET REG 15 = 0
         L     1,=AL1(C' ',0,0,0)  LOAD FILL CHARACTER
         IC    15,1(,3)            LOAD NUMBER OF BLANKS TO INSERT
         AHI   3,2                 COMPUTE ADDRESS OF THE NEXT FORMAT
         MVCL  14,0                INSERT THE BLANKS
         J     MFMT0100            GO PROCESS THE NEXT FORMAT
* TRANSLATE DCBRECFM TO A CHARACTER STRING
MFMT6600 SR    6,6                 SET REG 6 = 0
         IC    6,2(,3)             LOAD THE OUTPUT LENGTH
         LA    1,3(,3)             LOAD ADDRESS OF THE ADDRESS
         BRAS  15,MFMT5900         GET THE ADDRESS
         MVC   MFMTWEWK(5),=CL8' ' CLEAR THE TEMPORARY OUTPUT
         TM    0(4),DCBRECL        TEST IF RECFM IS VALID
         JNZ   MFMT6610            BR IF A RECORD TYPE IS DEFINED
         MVI   MFMTWEWK,C'?'       INDICATE RECFM IS INVALID
         LA    15,MFMTWEWK+1       SET REG 15 = END OF DATA
         J     MFMT7200            AND EXIT
MFMT6610 LA    15,MFMTWEWK         LOAD ADDRESS OF THE TEMPORARY OUTPUT
         LA    0,MFMT7800          LOAD ENTRIES IN THE CONVERSION TABLE
         LA    1,MFMT7700          LOAD ADDR OF THE CONVERSION TABLE
MFMT6700 MVC   MFMTWEWK+5(1),0(4)  SAVE A COPY OF THE RECFM
         NC    MFMTWEWK+5(1),0(1)  ISOLATE TEST BITS
         CLC   MFMTWEWK+5(1),1(1)  TEST RECFM
         JNE   MFMT6800            BR OPTION NOT PRESENT
         MVC   0(1,15),2(1)        COPY THE OPTION CHARACTER
         AHI   15,1                UPDATE THE OUTPUT ADDR
MFMT6800 AHI   1,3                 COMPUTE ADDR OF NEXT RECFM         ->
                                    CONVERSION TABLE ENTRY
         BRCT  0,MFMT6700          GO DO IT
         J     MFMT7200
* TRANSLATE DCBDSORG TO A CHARACTER STRING
MFMT6900 SR    6,6                 SET OUTPUT LENGTH = 0
         IC    6,2(,3)             LOAD OUTPUT LENGTH
         LA    1,3(,3)             LOAD ADDRESS OF THE ADDRESS
         BRAS  15,MFMT5900         GET THE ACTUAL ADDRESS
         LA    0,MFMT8000          LOAD ENTRIES IN DSORG TABLE
         LA    1,MFMT7900          LOAD ADDR OF START OF THE DSORG TAB
MFMT7000 CLC   0(2,4),0(1)         TEST IF MATCH
         JE    MFMT7100            BE IF SO
         AHI   1,5                 COMPUTE ADDR OF NEXT DSORG ENTRY
         BRCT  0,MFMT7000          GO CHECK IT
MFMT7100 MVC   MFMTWEWK(3),2(1)    COPY DSORG TEXT
         LA    15,MFMTWEWK+3       LOAD END OF DSORG
         CLI   MFMTWEWK+2,C' '     TEST IF 3 BYTE DSORG
         BNE   MFMT7200            BR IF SO
         BCTR  15,0                RESET END OF DSORG
MFMT7200 LR    5,15                COPY END OF TEXT TO REG 5
         LA    4,MFMTWEWK          LOAD ADDRESS OF CONVERTED TEXT
         SR    5,4                 COMPUTE LENGTH OF CONVERTED TEXT
         LTR   6,6                 TEST OUTPUT LENGTH
         JNZ   *+L'*+2             BR IF OUTPUT LENGTH DEFINED
         LR    6,5                 COPY INPUT LENGTH TO OUTPUT LENGTH
         O     5,=AL1(C' ',0,0,0)  ADD FILL CHARACTER TO INPUT LENGTH
         LR    15,6                COPY OUTPUT LENGTH TO REG 15
         MVCL  14,4                COPY RECFM TEXT TO OUTPUT
         J     MFMT0100            GO DO THE NEXT FORMAT
* TAB -- REPOSITION OUTPUT POINTER, INSERT BLANKS IF TAB > CURRENT
*        LINE POSITION
MFMT7300 SR    15,15               SET REG 15 = 0
         IC    15,1(,3)            LOAD TAB POSITION
         AHI   3,2                 UPDATE FORMAT POSITION
         LA    15,MFMTWLNE+4(15)   COMPUTE TAB POSITION IN OUTPUT     ->
                                    BUFFER
         CR    15,14               COMPARE TAB POSITION W/ CURRENT    ->
                                    LINE POSITION
         JH    MFMT7400            BR IF FORWARD TAB
         JE    MFMT0100            NO MOVEMENT, IGNORE
         LR    14,15               BACKWARDS, SET NEW OUTPUT POSITION
         J     MFMT0100            GO DO THE NEXT FORMAT
MFMT7400 SR    15,14               COMPUTE NUMBER OF BLANKS TO INSERT
         L     1,=AL1(C' ',0,0,0)  LOAD FILL CHARACTER INTO REG 1
         MVCL  14,0                INSERT BLANKS TO NEW TAB
         J     MFMT0100            GO DO THE NEXT FORMAT
MFMT7500 MVC   0(5,14),=C'*FMT*'   INDICATE A FORMAT PROBLEM
         AHI   14,5                UPDATE THE OUTPUT POINTER
MFMT7600 LA    1,MFMTWLNE          LOAD ADDR OF GENERATED LINE
         SR    14,1                COMPUTE LENGTH OF GENERATED LINE
         STH   14,0(,1)            STORE LENGTH IN THE RDW
         XC    2(2,1),2(1)         CLEAR THE REMAINDER OF THE RDW
         ST    1,24(,13)           REPLACE CALLER'S REG 1 WITH        ->
                                    ADDRESS OF GENERATED OUTPUT LINE
         RETURN (14,12),T          RESTORE REGS & RETURN TO CALLER
MFMT7700 DC    AL1(DCBRECL,DCBRECF,C'F') TABLE TO
         DC    AL1(DCBRECL,DCBRECV,C'V')  TRANSLATE
         DC    AL1(DCBRECL,DCBRECU,C'U')   DCBRECFM
*        DC    AL1(DCBRECL,0,C'?')          TO A
         DC    AL1(DCBRECBR,DCBRECBR,C'B')   CHARACTER
         DC    AL1(DCBRECSB,DCBRECSB,C'S')    STRING
         DC    AL1(DCBRECTO,DCBRECTO,C'T')
         DC    AL1(DCBRECCC,DCBRECCA,C'A')
         DC    AL1(DCBRECCC,DCBRECCM,C'M')
MFMT7800 EQU   (*-MFMT7700)/3      NUMBER OF ENTRIES IN MFMT7700 TABLE
MFMT7900 DC    AL1(DCBDSGPS,0),CL3'PS'         TABLE TO
         DC    AL1(DCBDSGPO,0),CL3'PO'          TRANSLATE
         DC    AL1(DCBDSGIS,0),CL3'IS'           DCBDSORG
         DC    AL1(DCBDSGDA,0),CL3'DA'            TO A
         DC    AL1(0,DCBACBM),CL3'VS'              CHARACTER STRING
         DC    AL1(DCBDSGPS+DCBDSGU,0),CL3'PSU'
         DC    AL1(DCBDSGPO+DCBDSGU,0),CL3'POU'
         DC    AL1(DCBDSGIS+DCBDSGU,0),CL3'ISU'
         DC    AL1(DCBDSGDA+DCBDSGU,0),CL3'DAU'
MFMT8000 EQU   (*-MFMT7900)/5      NUMBER OF ENTRIES IN MFMT7900 TABLE
         DC    2AL1(0),CL3'??'
* THE MFMT8100 TABLE TRANSLATES A REGISTER NUMBER TO THE OFFSET
* OF THE REGISTER LOCATION IN THE SAVE AREA USED WHEN MINIFMT IS
* CALLED.  SINCE REGISTERS 14, 15, 0 AND 1 ARE LINK REGISTERS WHEN
* MICROFMT IS CALLED THEY ARE NOT VERY USEFUL FOR THE PURPOSE, BUT
* REGISTERS 2 THROUGH 13 ARE USEFUL.
*             REG 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
MFMT8100 DC    A(20,24,28,32,36,40,44,48,52,56,60,64,68,99,12,16)
MFMT8200 EQU   *-C'0'
         DC    C'0123456789ABCDEF'
*                  ----+----1----+
MFMT8300 DC    0C' 999999999999999',C' ',13X'20',X'2120'
MFMT8310 DC    0C' 999,999,999,999,999'
         DC    C' ',3X'20',C',',3X'20',C',',3X'20',C',',3X'20',C',',X'2>
               02120'
*                 0----+---
MFMT8400 DC    0C'0HH:MM:SS',C'0',X'2120',C':',X'2020',C':',X'2020'
* DAY OF YEAR FOR 1ST DAY OF MONTH
         DC    0H'0'
MFMT8500 EQU   *-2
         DC    AL2(0)                                JANUARY
         DC    AL2(31)                               FEBRUARY
         DC    AL2(31+29)                            MARCH
         DC    AL2(31+29+31)                         APRIL
         DC    AL2(31+29+31+30)                      MAY
         DC    AL2(31+29+31+30+31)                   JUNE
         DC    AL2(31+29+31+30+31+30)                JULY
         DC    AL2(31+29+31+30+31+30+31)             AUGUST
*                                                    ----+----
         DC    AL2(31+29+31+30+31+30+31+31)          SEPTEMBER
         DC    AL2(31+29+31+30+31+30+31+31+30)       OCTOBER
         DC    AL2(31+29+31+30+31+30+31+31+30+31)    NOVEMBER
         DC    AL2(31+29+31+30+31+30+31+31+30+31+30) DECEMBER
* TRANSLATE DAY OF YEAR TO MONTH
* JANUARY TO JUNE
MFMT8600 DC    32AL1(1),29AL1(2),31AL1(3),30AL1(4),31AL1(5),30AL1(6)
* JULY TO DECEMBER
         DC    31AL1(7),31AL1(8),30AL1(9),31AL1(10),30AL1(11),31AL1(12)
* MONTH NUMBER TO MONTH NAME, ABBREVIATED MONTH NAME IS THE FIRST 3
* CHARACTERS OF THE FULL MONTH NAME
MFMT8700 DC    CL9'--'
         DC    CL9'JANUARY',CL9'FEBRUARY',CL9'MARCH'
         DC    CL9'APRIL',CL9'MAY',CL9'JUNE'
         DC    CL9'JULY',CL9'AUGUST',CL9'SEPTEMBER'
         DC    CL9'OCTOBER',CL9'NOVEMBER',CL9'DECEMBER'
         DC    0D'0'
         LTORG ,
         DC    0D'0'
         DROP  ,
         TITLE 'CNVTBIN -- Translate Time of Day As Returned by TIME BI>
               N to Time of Day As Returned by TIME DEC'
***********************************************************************
*                                                                     *
* Title -- CNVTBIN                                                    *
*                                                                     *
* Function / Operation -- CNVTBIN converts the time of day as         *
*   returned by the TIME BIN macro to the time of day as returned     *
*   by the TIME DEC macro.                                            *
*                                                                     *
* Calling Sequence --                                                 *
*   ----+----1----+----2----+----3----+----4----+----5----+----6----+ *
*            TIME  BIN                 (or equivalent)                *
*            L     15,=V(CNVTBIN)      Load address of CNVTBIN        *
*            BASR  14,15               Convert binary time of day     *
*   *                                   to 8 packed decimal digits    *
*   * Time of day is in reg 0                                         *
*   * CNVTBIN can also be called using the BRAS or BRASL instructions *
*                                                                     *
* Status / Change Level --                                            *
*   V2L0 -- May 2010                                                  *
*    - Replace lost source                                            *
*                                                                     *
* Method of Operation -- Prepare a binary number that is the analog   *
*   of the number returned by TIME DEC, convert the number to the     *
*   5 byte equivalent of the packed decimal equivalent of the value   *
*   returned by TIME DEC, store the decimal digits in reg 0 and       *
*   return.                                                           *
*                                                                     *
***********************************************************************
         SPACE 5
         ENTRY CNVTBIN
         AGO   .NEWBIN
CNVTBIN  BASR  15,0                STORE CURRENT ADDRESS IN REG 15
         USING *,15                ESTABLISH ADDRESSABILITY
         SAVE  (14,3),,CNVTBIN     SAVE REGISTERS 14 THROUGH 3        ->
                                    (THE SAVE AREA POSITIONS FOR      ->
                                     REGISTERS 11 AND 12 WILL BE USED ->
                                      AS A WORK AREA)
         LR    3,0                 COPY THE TIME BIN VALUE TO REG 3
         SR    2,2                 SET REG 2 = 0
         D     2,=F'100'           DIVIDE BY NUMBER OF 1/100TH OF A   ->
                                    SECONDS IN A SECOND
         LR    0,2                 COPY 1/100THS OF A SECOND TO REG 0
         SR    2,2                 SET REG 2 = 0
         D     2,=F'60'            DIVIDE SECONDS BY SECONDS IN 1     ->
                                    MINUTE
         MHI   2,100               MULTIPLY SECONDS BY 100
         AR    0,2                 ADD TO TOTAL
         SR    2,2                 SET REG 2 = 0
         D     2,=F'60'            DIVIDE MINUTES BY 60
* WE HAVE MINUTES IN AN HOUR IN REG 2, AND THE HOUR OF THE DAY IN REG 3
         MHI   2,10000             MULTIPLY MINUTES BY 10000
         AR    0,2                 ADD TO TOTAL
         SR    2,2                 SET REG 2 = 0
         M     2,=F'1000000'       MULTIPLY HOUR OF THE DAY BY 1000000
         AR    0,3                 ADD TO TOTAL
         CVD   0,64(,13)           CONVERT TIME TO PACKED DECIMAL
         LM    0,1,64(13)          LOAD TIME
         SRDL  0,4                 REMOVE THE PACKED DECIMAL SIGN
         ST    1,20(,13)           REPLACE CALLER'S REG 0 WITH RESULT
         RETURN (14,3),T           RESTORE CALLER'S REGISTERS & RETURN
         DC    0D'0'               FORCE DOUBLE WORD ALIGNMENT
         LTORG ,                   DEFINE THE LITERAL POOL
         DC    0D'0'               FORCE DOUBLE WORD ALIGNMENT
         SPACE 1
         DROP  ,                   KILL ADDRESSABILITY
.NEWBIN  ANOP
CNVTBIN  BASR  15,0                Store current address in reg 15
         USING *,15                Establish addressability
         SAVE  (14,1),,CNVTBIN     Save registers
         LR    1,0                 Copy reg 0 to reg 1
         SR    0,0                 Compute minutes (in reg 1)
         D     0,=F'6000'           and seconds (in reg 0)
         LR    14,0                Copy seconds to reg 14
         SR    0,0                 Compute hours (in reg 1)
         D     0,=F'60'             and minutes (in reg 0)
         MHI   0,10000             Multiply minutes by 10000
         AR    14,0                Combine minutes and seconds
         MHI   1,1000              Multiply hours by 1000000
         MHI   1,1000
         AR    14,1                Combine hours with minutes & seconds
         MHI   14,10               Multiply F'hhmmssss' by 10
         CVD   14,64(,13)          Convert F'hhmmssss0' to decimal
         MVC   20(4,13),67(13)     Replace caller's reg 0 with hhmmssss
         RETURN (14,1)             Restore registers & return
         DC    0D'0'
         LTORG ,
         DC    0D'0'
         DROP   ,                  Kill addressability
         TITLE 'LJUST            L E F T   J U S T I F Y   R I G H T   >
               J U S T I F I E D   D A T A'
* Left justify right justified justifed data
*          LA    0,L'DATA
*          LA    1,DATA
*          L     15,=V(LJUST)
*          CALL  (15)
*          ...
* DATA     DC    C'  DATA'
*
* Output is C'DATA  '
*
* An alternative, slightly faster though more expensive in storage,
* inplementation is expressed in comments.
         SPACE 1
         ENTRY LJUST               Define external entry point
LJUST    BASR  15,0                Store current address in reg 15
         USING *,4                 Establish program addressability
         SAVE  (14,4),,LJUST       Save registers
         LR    4,15                Prepare base register
         LR    14,1                Copy start of data to reg 14 and
         LR    2,1                  reg 2
         LTR   3,0                 Copy length to reg 3
         JNP   LJ0300              Br if length is bad
**       LA    1,0(3,2)            Compute address of end of data
*        LR    15,0                Copy length to reg 15
*        BCTR  15,0                Compute length to test
*        EX    15,LJ0500           Find first non-blank
*        JZ    LJ0300              All blanka, exit
LJ0100   TM    0(1),255-C' '       Find first non-blank
         JNZ   LJ0200              Br if found
         AHI   1,1                 Update reg 1
         BRCT  0,LJ0100            Keep on looking
         J     LJ0300              All blanks, exit
LJ0200   CR    14,1                Test if already left justified
         JE    LJ0300              Br if so
         LA    15,0(3,2)           Compute addr of end of data
         SR    15,1                Compute length to copy
         JNP   LJ0300              Oops
         BCTR  15,0                Reduce length by 1 for hardware
         EX    15,LJ0400           Left justify the data
         LA    14,1(15,14)         Compute end of string we just copied
         LA    15,0(3,2)           Compute end of data
         SR    15,14               Compute bytes to blank
         JNP   LJ0300              Br if none
         L     1,LJ0600            Load the fill character
         MVCL  14,0                Fill the vacated data with blanks
LJ0300   RETURN (14,4)             Restore registers & return
LJ0400   MVC   0(*-*,14),0(1)    **EX only **
*LJ0500  TRT   0(*-*,14),LJ0700  **EX only **
LJ0600   DC    0A(0),C' ',3AL1(0)
         DC    0D'0'
*LJ0700  DC    X'00',(C' '-(*-LJ0700))X'04',X'00',(256-(*-LJ0700))X'04'
         END   ,
QSORTS   TITLE '                        Q S O R T   A N D   Q S O R T L>
                  F U N C T I O N S'
***********************************************************************
*                                                                     *
* TITLE -- QSORT                                                      *
*                                                                     *
* FUNCTION / OPERATION -- THIS MODULE OPERATES AS A SHELL BETWEEN A   *
*   CALLING PROGRAM AND A COMPARE PROGRAM.  THE EFFECT OF THE SHELL   *
*   IS TO SORT DATA IN ASCENDING ORDER, DEPENDING ON THE RESULTS      *
*   RETURNED BY THE COMPARE PROGRAM                                   *
*                                                                     *
* STATUS / CHANGE LEVEL --                                            *
*   V1L2 -- SEP 2017                                                  *
*    - BC INSTRUCTIONS ALTERED TO BRC INSTRUCTIONS.                   *
*    - QSORTS CSECT DEFINED AS READ ONLY.                             *
*    - MINOR PERFORMANCE TWEAKING DONE.                               *
*    - VERSION MARKERS UPDATED.                                       *
*    - PAGE HEADER ALTERED TO REMOVE REFERENCE TO QUICKSORT.          *
*   V1L1 -- OCT 14, 1997                                              *
*     UPDATE QSORT TO DO NO PROCESSING IF N <= 1                      *
*   V1L0 -- FEB 28, 1993                                              *
*                                                                     *
* CALLING SEQUENCE --                                                 *
*                                                                     *
*          CALL QSORT,(BASE,N,WIDTH,COMPARE,WORK)                     *
*                                                                     *
*    BASE    -- THE FIRST ELEMENT IN AN ARRAY OF ELEMENTS TO SORT     *
*    COMPARE -- THE ADDRESS OF A ROUTINE USED TO COMPARE TWO ELEMENTS *
*               OF THE DATA AREA                                      *
*    N       -- A FULL WORD CONTAINING THE NUMBER OF ELEMENTS TO SORT *
*    WIDTH   -- A FULL WORD CONTAINING THE NUMBER OF BYTES IN EACH    *
*               ELEMENT.  THE MAXIMUM VALUE IS 256.                   *
*    WORK    -- A 100 BYTE DATA AREA USED AS A WORK AREA              *
*                                                                     *
*    COMPARE ROUTINE --                                               *
*      THE COMPARE ROUTINE IS CALLED WITH THIS CALLING SEQUENCE --    *
*                                                                     *
*               CALL COMPARE,(ELEMENT1,ELEMENT2)                      *
*                                                                     *
*      THE RETURN CODE IN REGISTER 15 EXPECTED FROM COMPARE IS --     *
*                                                                     *
*        ELEMENT1 < ELEMENT2 -- LESS THAN 0                           *
*        ELEMENT1 = ELEMENT2 -- 0                                     *
*        ELEMENT1 > ELEMENT2 -- GREATER THAN 0                        *
*                                                                     *
* ATTRIBUTES -- QSORT IS REENTRANT, REFRESHABLE AND RESUABLE.  IT     *
*   USES NO EXTERNAL SYSTEM RESOURCES.  IT OPERATES AMODE ANY,        *
*   RMODE ANY.  IT DOES NOT SUPPORT OPERATION IN AR MODE              *
*                                                                     *
***********************************************************************
         EJECT
         MACRO
         SETR
         LCLA  &A
.L       AIF   (&A GT 15).X
R&A      EQU   &A
&A       SETA  &A+1
         AGO   .L
.X       MEND
*        CALL  QSORT( BASE, NUM, WIDTH, COMPARE, WORK )
*
* THIS ROUTINE IS BASED ON THE FOLLOWING C PROGRAM
*
* VOID SORT( CHAR *ARRAY, INT N )
*  {
*   INT GAP, I, J, TEMP;
*
*   FOR ( GAP = N / 2; GAP > 0; GAP /= 2 )
*    FOR ( I = GAP; I < N; I++ )
*     FOR ( J = I - GAP;
*           J >= 0 && ARRAY(J) > ARRAY(J + GAP);
*           J -= GAP )
*      {
*       TEMP = ARRAY(J);
*       ARRAY(J) = ARRAY( J + GAP );
*       ARRAY( J + GAP ) = TEMP;
*      }
*  }
         SPACE 1
QSORTS   RSECT                     DEFINE PROGRAM CSECT            V1L2
         SPACE 1
QSORTS   AMODE ANY                 DEFINE AMODE
QSORTS   RMODE ANY                 DEFINE RMODE
         SPACE 1
         ENTRY QSORT,QSORTL
         SPACE 1
         SYSSTATE ARCHLVL=2                                        V1L2
         SR    R15,R15             SET R15 = 0
         BR    R14                 RETURN IF QSORTS CALLED
         SPACE 1
      DC    C'QSORT AND QSORTL ROUTINES -- V1L2 &SYSDATE &SYSTIME' V1L2
         DC    0D'0'
         SPACE 1
N        EQU   R3                  N
WIDTH    EQU   R4                  WIDTH
GAP      EQU   R6                  GAP
I        EQU   R7                  I
J        EQU   R8                  J
         SPACE 1
         USING *,R12               ESTABLISH ADDRESSABILITY
QSORT    SAVE  (14,12),,*          SAVE CALLER'S REGISTERS
         LR    R12,R15             COPY EP ADDRESS TO R12
         LM    R2,R6,0(R1)         LOAD THE REGISTERS
         ST    R6,8(,R13)          ADD THE NEW SAVE AREA TO THE
         ST    R13,4(,R6)           CALLER'S SAVE AREA CHAIN
         LR    R13,R6              ESTABLISH THE NEW SAVE AREA
         L     R3,0(,R3)           LOAD VALUE OF NUM
         CHI   R3,1                COMPARE VALUE W/ 1              V1L2
         JNH   QSO0600             BR IF 0 OR 1                    V1L2
         L     R4,0(,R4)           LOAD VALUE OF WIDTH
*   FOR ( GAP = N / 2; GAP > 0; GAP /= 2 )
         LR    GAP,N               COPY N TO GAP
         CNOP  0,8
QSO0100  SRA   GAP,1               DIVIDE N BY 2
*        LTR   GAP,GAP             TEST IF DONE (SRA SETS THE CC)  V1L2
         JZ    QSO0600             BR IF SO                        V1L2
*    FOR ( I = GAP; I < N; I++ )
         LR    I,GAP               COPY GAP TO I
QSO0200  CR    I,N                 COMPARE I AND N
         JNL   QSO0100             BR IF NOT A MATCH               V1L2
*     FOR ( J = I - GAP;
*           J >= 0 && ARRAY(J) > ARRAY(J + GAP);
*           J -= GAP )
         LR    J,I                 COPY I TO J
         SR    J,GAP               SUBTRACT GAP FROM I
QSO0300  LTR   J,J                 COMPARE J AND 0
         JL    QSO0500             BR IF DONE                      V1L2
         LR    R15,J               COPY J TO R15
         MR    R14,WIDTH           COMPUTE TRUE OFFSET
         LA    R9,0(R15,R2)        COMPUTE ADDRESS
         LR    R15,J               COPY J TO R15
         AR    R15,GAP             ADD GAP
         MR    R14,WIDTH           COMPUTE TRUE OFFSET
         LA    R10,0(R15,R2)       COMPUTE ADDRESS
         LR    R15,R5              COPY COMPARE ROUTINE ADDRESS TO R15
         CALL  (15),((R9),(R10)),MF=(E,72(,R13)) CALL THE COMPARE PGM
         LTR   R15,R15             TEST RC FROM COMPARE
         JNH   QSO0500             BR IF DONE                      V1L2
         LR    R1,WIDTH            COPY WIDTH TO R1
         BCTR  R1,0                REDUCE BY 1
         EX    R1,SWITCH1          EXCHANGE THE TWO ELEMENTS
         EX    R1,SWITCH2
         EX    R1,SWITCH1
QSO0400  SR    J,GAP               SUBTRACT GAP FROM J
         J     QSO0300             TEST IF FOR IS DONE             V1L2
         SPACE 1
QSO0500  LA    I,1(,I)             ADD 1 TO I
         J     QSO0200             TEST IF FOR IS DONE             V1L2
         SPACE 1
QSO0600  L     R13,4(,R13)         RESTORE ADDR OF CALLER'S SAVE AREA
         RETURN (14,12),T          RETURN TO CALLER
         SPACE 1
         CNOP  0,8
SWITCH1  XC    0(*-*,R9),0(R10)
SWITCH2  XC    0(*-*,R10),0(R9)
         SPACE 1
         CNOP  0,8
         LTORG ,
         EJECT
***********************************************************************
*                                                                     *
* TITLE -- QSORTL                                                     *
*                                                                     *
* FUNCTION / OPERATION -- QSORTL ACTS AS AN INTERFACE BETWEEN ANOTHER *
*   PROGRAM AND THE QSORT PROGRAM.  QSORTL SORTS A LIST OF ELEMENTS   *
*   THAT ARE ON A CHAIN.  IT DOES THIS BY RUNNING THE CHAIN TO        *
*   PRODUCE A POINTER LIST, THEN USES QSORT TO SORT THE POINTER LIST. *
*   AFTER QSORT TERMINATES THE CHAIN IS REBUILT IN SORTED ORDER BY    *
*   UPDATING THE POINTER ELEMENTS.                                    *
*                                                                     *
*                                                                     *
* STATUS / CHANGE LEVEL --                                            *
*   V1L1 -- APR 2016                                                  *
*    - ALLOCATE THE WORK AREA ABOVE THE LINE IF RUNNING AMODE 31      *
*   V1L0 -- MAR 31, 1993                                              *
*                                                                     *
* CALLING SEQUENCE --                                                 *
*   CALL QSORTL,(BASE,OFFSET,COMPARE)                                 *
*                                                                     *
*     BASE    -- ADDRESS OF A POINTER TO THE FIRST ELEMENT OF THE     *
*                CHAIN                                                *
*     OFFSET  -- OFFSET OF THE 4 BYTE POINTER TO THE NEXT ELEMENT     *
*                IN THE CHAIN.  A POINTER VALUE OF 0 INDICATES THE    *
*                LAST ELEMENT IN THE CHAIN.                           *
*     COMPARE -- COMPARE ROUTINE, AS USED BY QSORT.  THE COMPARE      *
*                ROUTINE SEES POINTERS TO THE DATA ELEMENT TO SORT.   *
*                                                                     *
* ATTRIBUTES -- QSORTL IS REENTRANT, REFRESHABLE AND REUSABLE.  IT    *
*   USES THE GETMAIN AND FREEMAIN SERVICE ROUTINE TO ALLOCATE AND     *
*   RELEASE STORAGE IN SUBPOOL 0.  IT OPERATES AMODE ANY, RMODE ANY.  *
*   AR MODE OPERATION IS NOT SUPPORT.                                 *
*                                                                     *
***********************************************************************
         CNOP  0,8
         SPACE 1
         USING *,R12               ESTABLISH PROGRAM ADDRESSABILITY
         USING QLWORK,R13          ESTABLISH WORK AREA ADDRESSABILITY
         SPACE 1
QSORTL   SAVE  (14,12),,*          SAVE REGISTERS
         LR    R12,R15             COPY EP ADDRESS TO R12
         LM    R2,R4,0(R1)         LOAD PARM LIST
         L     R3,0(,R3)           LOAD VALUE OF OFFSET
         SPACE 1
* COUNT THE NUMBER OF ELEMENTS ON THE CHAIN
         SPACE 1
         SR    R7,R7               SET COUNT = 0
         L     R6,0(,R2)           LOAD ADDRESS OF THE FIRST ELEMENT
QL0100   LTR   R6,R6               TEST IF END OF CHAIN
         JZ    QL0200              BR IF END                       V1L2
         L     R6,0(R3,R6)         LOAD ADDRESS OF THE NEXT ELEMENT
         LA    R7,1(,R7)           ADD 1 TO COUNT
         J     QL0100              AND CONTINUE                    V1L2
         SPACE 1
* MAKE SURE THE CHAIN IS WORTH SORTING
         SPACE 1
QL0200   C     R7,=F'1'            COMPARE COUNT WITH 1
         JNH   QL0800              EXIT IF COUNT <= 1              V1L2
         SPACE 1
* CALCULATE THE SIZE OF THE WORK AREA WE WILL ALLOCATE.  THE WORK
* AREA CONTAINS A FIXED BASE AREA FOLLOWED BY POINTER LIST WE PASS TO
* QSORT.
         SPACE 1
         LR    R6,R7               COPY COUNT TO R6
         SLL   R6,2                MULTIPLY COUNT BY 4
         LA    R6,QLWORKL+7(,R6)   COMPUTE TOTAL SIZE TO ALLOCATE
         SPACE 1
* ALLOCATE THE WORK AREA
         SPACE 1
         N     R6,=F'-8'           ROUND DOWN TO A DOUBLE WORD
         TAM   ,                   TEST THE ADDRESSING MODE
         JZ    QL0300              BR IF AMODE 24                  V1L2
         GETMAIN RU,LV=(R6),LOC=(31,ANY)  ALLOCATE THE WORK AREA
         J     QL0400                                              V1L2
QL0300   GETMAIN RU,LV=(R6),LOC=(24,ANY)  ALLOCATE THE WORK AREA
         SPACE 1
* ADD THE CHAIN AREA IN THE WORK AREA TO THE SAVE AREA CHAIN
         SPACE 1
QL0400   ST    R13,QLS-QLWORK+4(,R1) ADD THE SAVE AREA TO THE
         ST    R1,8(,R13)             SAVE AREA CHAIN
         LR    R13,R1              ESTABLISH A NEW SAVE AREA ADDRESS
         SPACE 1
* INITIALIZE ADDITIONAL DATA AREAS
         SPACE 1
         ST    R6,QLSSIZE          SAVE THE WORK AREA SIZE
         ST    R7,QLCOUNT          SAVE COUNT
         SPACE 1
* BUILD THE POINTER LIST
         SPACE 1
         LA    R1,QLPTRS           LOAD ADDR OF THE FIRST POINTER
         L     R6,0(,R2)           LOAD ADDRESS OF THE FIRST ELEMENT
QL0500   LTR   R6,R6               TEST IF END OF CHAIN
         JZ    QL0600              BR IF SO                        V1L2
         ST    R6,0(,R1)           SAVE ADDRESS
         LA    R1,4(,R1)           COMPUTE NEXT POINTER ADDRESS
         L     R6,0(R3,R6)         LOAD ADDRESS OF THE NEXT AREA
         J     QL0500                                              V1L2
         SPACE 1
* USE QSORT TO SORT THE POINTER LIST
         SPACE 1
QL0600   L     R15,=A(QSORT)       LOAD START OF QSORT
         CALL  (15),(QLPTRS,QLCOUNT,QLWIDTH,(R4),QLSWORK),MF=(E,QSPARM)
         SPACE 1
* REBUILD THE CHAIN IN SORTED ORDER USING THE POINTER LIST
         SPACE 1
         SR    R2,R3               MAKE POINTER TO 1ST ELEMENT A DUMMY ?
                                    ELEMENT
         LA    R1,QLPTRS           LOAD ADDRESS OF THE FIRST POINTER
QL0700   LA    R6,0(R3,R2)         COMPUTE ADDRESS OF POINTER TO       ?
                                    NEXT ELEMENT
         MVC   0(4,R6),0(R1)       COPY POINTER
         L     R2,0(,R1)           LOAD ADDRESS OF THE ELEMENT
         LA    R1,4(,R1)           COMPUTE NEXT POINTER ADDRESS
         BRCT  R7,QL0700           GO DO THE NEXT ELEMENT          V1L2
         LA    R6,0(R3,R2)         COMPUTE ADDRESS OF POINTER TO       ?
                                    NEXT ELEMENT
         XC    0(4,R6),0(R6)       CLEAR POINTER IN LAST ELEMENT
         SPACE 1
* RELEASE THE ALLOCATED STORAGE
         SPACE 1
         L     R0,QLSSIZE          LOAD SIZE OF ALLOCATED STORAGE
         LR    R1,R13              COPY ADDRESS TO R1
         L     R13,4(,R13)         LOAD ADDR OF THE CALLER'S SAVE AREA
         FREEMAIN RU,LV=(0),A=(1)  RELEASE STORAGE
         SPACE 1
* RETURN
         SPACE 1
QL0800   RETURN (14,12),T          RETURN TO CALLER
         SPACE 1
QLWIDTH  DC    F'4'                VALUE OF 4
         SPACE 1
         DC    0D'0'
         LTORG ,
         DC    0D'0'                                               V1L2
         SPACE 1
QLWORK   DSECT                     WORK AREA
QLS      DS    9D                  SAVE AREA
QLSWORK  DS    XL100               QSORT WORK AREA
QLSSIZE  DS    F                   SIZE OF THIS WORK AREA
QLCOUNT  DS    F                   NUMBER OF ELEMENTS
QSPARM   CALL  ,(*-*,*-*,*-*,*-*,*-*),MF=L QSORT PARM LIST
QLWORKL  EQU   *-QLWORK            LENGTH OF BASE PORTION
QLPTRS   DS    0A                  FIRST POINTER
         SETR  ,
         END   ,
