KEEPITUP TITLE '                    W A I T   A   T S O   S E S S I O N>
                  I N D E F I N I T L Y'
***********************************************************************
*                                                                     *
* Title -- KEEPITUP                                                   *
*                                                                     *
* Function / Operation -- KEEPITUP waits a TSO session indefinitely.  *
*   Once an hour, on the hour, it writes a status message showing     *
*   the day of the week, the date and time.  On entry it clears the   *
*   screen using the CLRSCRN TSO command.                             *
*                                                                     *
* Command line --                                                     *
*   KEEPITUP  VERSION  TEST  MAXWAIT(minutes)  INTERVAL(minutes)      *
*      LONGHEADER\LONGHDR\LH
*     VERSION -- At the top of each screen write a message showing    *
*      the KEEPITUP version and the date and time it was assembled.   *
*     TEST -- Do not use the STAX macro in a testing mode so that an  *
*      attention will go to the standard system attention interrupt   *
*      handler.                                                       *
*     INTERVAL(minutes) -- minutes specifies the number of minutes    *
*      between screen updates, between 1 and 1440.                    *
*     MAXWAIT(minutes) -- minutes specifies the maximum number of     *
*      minutes KEEPITUP can wait.  The time can be specified as 1 or  *
*      2 digits.  A value greater than the value specified in the     *
*      INTERVAL keyword is effectively ignored.  The time should be   *
*      less than the SMF JWT time.                                    *
*     LONGHEADER\LONGHDR\LH -- Write a "long" header line as the      *
*      first line on the screen.  This line includes the INTERVAL and *
*      MAXWAIT values.                                                *
*     Default - MAXWAIT(5)  INTERVAL(60)                              *
*     VERSION, TEST and MAXWAIT are keywords, so the usual IKJPARS    *
*      alternate keywords can be used.                                *
*     VERSION, TEST, INTERVAL and MAXWAIT are keywords, so the usual  *
*      IKJPARS keyword shortcus can be used.                          *
*                                                                     *
* Attributes -- KEEPITUP is reenterable, refreshable and reusable.    *
*   It operates in task mode, enabled, problem key and problem state  *
*   as a TSO command processor.  It uses no APF restricted z/OS       *
*   resources.                                                        *
*                                                                     *
* Status /Change Level --                                             *
*   V2L4 -- September 2021                                            *
*    - LINK to CLRSCRN rather than LOAD / CALL; the real CLRSCRN is   *
*      not reenterable                                                *
*    - Display logon time as n D h H m M s S in detail message        *
*   V2L3 -- September 2019                                            *
*    - Remove system ID from the standard header                      *
*    - Verion corrected in FMT03 message                              *
*   V2L2 -- July 2016                                                 *
*    - Verify interval time is a proper fraction of 60 minutes or     *
*      24 hours.  The prime factors of 1440 (the number of minutes in *
*      24 hours) are 2 * 2 * 2 * 2 * 2 * 3 * 3 * 5, so there are very *
*      few valid values > 60.                                         *
*    - Display INTERVAL and MAXWAIT values in the top of screen       *
*      message when the LONGHEADER keyword is specified in the        *
*      command line.                                                  *
*    - Display session elapsed time                                   *
*   V1L1 -- June 2016                                                 *
*    - Allow interval time to be specified in the command line        *
*    - Validate MAXWAIT and INTERVAL using IKJPARS validity check     *
*      exit.  0 is rejected, INTERVAL > 1440 is rejected, MAXWAIT >   *
*      SMF JWT is rejected.                                           *
*   V1L0 -- May 2016                                                  *
*                                                                     *
* Messages --                                                         *
*  KEEPITUP RUNNING ON SYS1 FOR ADUMMY STARTED AT  2:31 PM            *
*  ON SUNDAY MAY 15 INTERVAL(n) MAXWAIT(n)                            *
*   Reason - This message appears at the top of each screen.  It      *
*    shows the SMF system ID (SYS1, the date and time it started      *
*    (2:31 PM ON SUNDAY MAY 15) and the INTERVAL and MAXWAIT values   *
*    specified in the command line.                                   *
*   Action - KEEPITUP continues running.                              *
*   Programmmer response - None required.                             *
*                                                                     *
*  IT IS SUNDAY, MAY 15, 2016 10:00:00 AM (16.136) hh:mm              *
*   Reason - This is the repeated status message.  KEEPITUP writes    *
*    the message when it starts and repeats it every hour on the      *
*    hour.  hh:mm represents the session time.                        *
*   Action - KEEPITUP continues running.                              *
*   Programmer response - None required.                              *
*                                                                     *
*  KEEPITUP V#L# mm/dd/yy hh:mm                                       *
*   Reason - This message appears when the VERSION parameter is       *
*    specified in the command line.                                   *
*   Action - KEEPITUP continues running.                              *
*   Programmer response - None required.                              *
*                                                                     *
* External functions -                                                *
*  - MINIFMT -- Create a message using a format                       *
*  - WEEKDAY -- Determine current day of week                         *
*  - CLRSCRN -- A TSO command processor to clear the 3270 screen      *
*                                                                     *
* Y2K & Y21K -- KEEPITUP is Y2K & Y21K compliant.  The year in the    *
*   KEEPITUP V#L# message is not compliant; rather it is from the     *
*   Assembler program.  The MINIFMT function creates dates in other   *
*   messages; they depend on MINIFMT being Y2K & Y21K compliant.      *
*   Although no year is displayed in the date in the KEEPITUP RUNNING *
*   ON message, it depends on MINIFMT being Y21K compliant.           *
*                                                                     *
***********************************************************************
         SPACE 5
KEEPITUP CSECT                     Define program CSECT
KEEPITUP AMODE 31                  Establish AMODE
KEEPITUP RMODE ANY
         USING PPL,11
         USING *,12                Establish addressability
         USING SAVE,13
         SAVE  (14,12),,'KEEPITUP &SYSDATE &SYSTIME'  Save registers
         LR    12,15               Prepare base register
         LR    2,1                 Copy CPPL address to reg 2
         LM    6,9,0(1)            Load the CPPL into regs 6 through 9
         LA    5,WASIZE            Allocate storage for the work area
         GETMAIN RU,LV=(5),LOC=(24,ANY)
         LR    4,1                 Copy address to reg 4
         LR    11,1                  and reg 11
         SR    15,15               Clear the work area
         MVCL  4,14
         LA    15,SAVEAREA         Compute new save area address
         ST    13,4(,15)           Add new save area to the
         ST    15,8(,13)            save area chain
         LR    13,15               Prepare new save area pointer
         TIMEUSED STORADR=STARTTM,CPU=MIC,LINKAGE=SYSTEM  Save start  ->
                                                           time
         ST    RCBUF,PPLCBUF       Initialize
         ST    RECT,PPLECT          the
         ST    RUPT,PPLUPT           Parse
         LA    0,TSOECB               Parameter
         ST    0,PPLECB                List
         LA    0,PDLPTR
         ST    0,PPLANS
         L     0,=A(TSOPCL)
         ST    0,PPLPCL
         L     0,=A(100*5*60)      Prepare MAXWAIT just in case
         ST    0,MAXWAIT            IKJPARS failed
         LINK  SF=(E,LINKPARS),MF=(E,(11))  Call IKJPARS
         LTR   15,15               IKJPARS OK?
         BNZ   NOPARS              No
         L     10,PDLPTR           Load address of the PDL
         USING TSOPDL,10           Establish PDL addressability
         LA    0,5                 Load the default MAXWAIT
         TM    PDLWAIT+6,X'80'     MAXWAIT specified?
         BZ    NOWAIT              No
         LH    15,PDLWAIT+4        Load the length of the string
         L     14,PDLWAIT          Load address of the string
         BCTR  15,0                Reduce the length by 1
         EX    15,PACKWAIT         Convert the string to decimal
         CVB   0,64(,13)           Convert the string to bunary
NOWAIT   ST    0,IMAXWAIT
         MHI   0,100*60            Multiply the string by timer units ->
                                    in 1 minute
         ST    0,MAXWAIT           Store the MAXWAIT
         LH    15,PDLINTV+4        Load bytes in interval time
         L     14,PDLINTV          Load address of the interval time
         BCTR  15,0                Reduce length by 1
         EX    15,PACKWAIT         Convert interval time to decimal
         CVB   0,64(,13)           Convert interval time to binary
         ST    0,IINTERVAL
         MHI   0,100*60            Multiply time by timer unite in    ->
                                    one minute
         ST    0,INTERVAL          Save the interval
         ICM   0,B'0011',PDLVER    Version?
         BZ    *+L'*+4             No
         OI    SWITCH,VER          Set the flag
         ICM   0,B'0011',PDLTEST   Test?
         BZ    *+L'*+4             No
         OI    SWITCH,TEST         Set the flag
         ICM   0,B'0011',PDLHDR
         BZ    *+L'*+4
         OI    SWITCH,LONGHDR
         DROP  10
         IKJRLSA PDLPTR            Free the PDL
NOPARS   MVC   ITIMEUP,ITIMEUPX    Initialize STIMER exit routine
         MVC   STAXEXIT,STAXXIT    Initialize STAX exit routine
         LA    0,(ECBX-ITIMEUPX)+ITIMEUP    Initialize the
         LA    1,(STAXECB-STAXXIT)+STAXEXIT  ECB list
         STM   0,1,ECBLIST
         OI    ECBLIST+4,X'80'
         TM    SWITCH,TEST
         BO    GETSIZE
         STAX  STAXEXIT,MF=(E,STAXPARM)  Prepare for an attention
GETSIZE  GTSIZE ,
         STC   0,SCRSIZE2          Store the screen size
         L     2,CVTPTR            Load address of the CVT
         L     3,CVTTCBP-CVTMAP(,2)  Load address of the TCB pointers
         L     3,4(,3)             Load address of the current TCB
         L     3,TCBTIO-TCB(,3)    Load addrsss of the TIOT
         L     2,CVTSMCA-CVTMAP(,2)  Load address of the SMCA
         L     15,=V(WEEKDAY)      Load address of WEEKDAY
         CALL  (15)                Call WEEKDAY
         MHI   15,L'DAYOFWEEK      Multiply day of the week by the    ->
                                    length of a week day name
         LA    4,DAYOFWEEK(15)     Compute address of the weekday name
         LA    0,FMTWORK           Prepare
         LA    1,FMT02              KEEPITUP STARTED ON ... message
         TM    SWITCH,LONGHDR
         BZ    *+L'*+4
         LA    1,FMT05
         L     15,=V(MINIFMT)
         CALL  (15)
         LR    0,1                 Copy the message to STARTBUF
         LH    1,0(,1)
         LA    14,STARTBUF
         LR    15,1
         MVCL  14,0
BIGLOOP  LINK  MF=(E,(2)),EP=CLRSCRN
         SR    3,3                 Load the screen size
         IC    3,SCRSIZE2
         AHI   3,-4                Subtract 4
         LA    15,4                Write the top of screen message
         LA    1,STARTBUF
         LH    0,0(,1)
         CHI   0,78+4              Message longer than 1 line?
         BNH   *+L'*+2             No
         BCTR  3,0                 Subtract 1 from screen size
         AR    1,15
         SR    0,15
         BNP   LOOP
         TPUT  (1),(0),R
         TM    SWITCH,VER
         BZ    LOOP
         LA    1,FMT03
         BAS   14,TPUTMSG
         BCTR  3,0
LOOP     L     15,=V(WEEKDAY)      Get the day of the week
         CALL  (15)
         MHI   15,L'DAYOFWEEK      Multiply day of week by bytes in   ->
                                    the day of week text
         LA    4,DAYOFWEEK(15)     Compute address of the weekday text
         TIME  BIN                 Get the current date & time
         STM   0,1,NOW             Save the current date & time
         L     15,CVTPTR           Obtain the address of the JMR
         L     15,CVTTCBP-CVTMAP(,15)  CVT -> TCB pointers ->
         L     15,4(,15)                current TCB -> TCT -> JMR
         L     15,TCBTCT-TCB(,15)
         L     10,TCTJMR-SMFTCT(,15)
         L     15,=V(SMFETIME)     Load address of SMFETIME to        ->
                                    calculate the session time
         CALL  (15),(JMRENTRY-JMR(,10),NOW,ELAPSED),MF=(E,EPARM)
         SR    0,0                 Load the session time
         L     1,ELAPSED
         D     0,=A(100)           Compute seconds
         SR    0,0
         D     0,=A(60)            Compute minutes & seconds
         ST    0,SECONDS           Save seconds
         LR    1,0                 Copy minutes to reg 1
         SR    0,0                 Convert minutes to hours & minutes
         D     0,=F'60'
         ST    0,MINUTES           Save minutes
         SR    0,0                 Convert hours to days & hours
         D     0,=F'24'
         ST    1,DAYS
         ST    0,HOURS
         LA    1,FMT01             Prepare and write IT IS ... msg
         BAS   14,TPUTMSG
SKIPMSG  TIME  BIN                 Get the time of day
         LR    5,0                 Copy the time of day to reg 5
         L     1,INTERVAL          Load timer units in 1 hour
         AR    5,1                 Add 1 hour to time of day
         SR    4,4                 Divide new time of day by timer
         DR    4,1                  units in 1 hour
         SR    4,4                 Convert hour of day to
         MR    4,1                  timer units
         SR    5,0                 Compute timer units to next hour
         L     0,MAXWAIT           Load MAXWAIT from the command line
         CR    5,0                 Test if MAXWAIT remains
         BNH   LASTSET             Br if less than MAXWAIT remains
         ST    0,WAITTIME          Wait for 5 minutes
         MVI   (ECBX-ITIMEUPX)+ITIMEUP,0  Reset the timer ECB
         STIMER REAL,ITIMEUP,BINTVL=WAITTIME  Start the time interval
         WAIT  1,ECBLIST=ECBLIST,LONG=YES  Wait for something to happen
         TM    (STAXECB-STAXXIT)+STAXEXIT,X'40'  Attention?
         BO    EXITX                             Yes
         B     SKIPMSG             Do it again
PACKWAIT PACK  64(8,13),0(*-*,14)  ** EX only **
LASTSET  ST    5,WAITTIME          Wait to the start of the next hour
         MVI   (ECBX-ITIMEUPX)+ITIMEUP,0  Reset the timer ECB
         STIMER REAL,ITIMEUP,BINTVL=WAITTIME  Start the time interval
         C     5,=A(100*5)         Test the time interval
         BNH   SHORTWAIT           Br if <= 5 seconds
         WAIT  1,ECBLIST=ECBLIST,LONG=YES  Wait for the timer to expire
         B     TESTECB
SHORTWAIT WAIT  1,ECBLIST=ECBLIST  Wait for the timer to expire
TESTECB  TM    (STAXECB-STAXXIT)+STAXEXIT,X'40'  Attention?
         BO    EXITX                             Yes
         BCT   3,LOOP              Br if the screen is not full
         B     BIGLOOP             Start a new screen
         USING SAVE,13
EXITX    TTIMER CANCEL             Just in case, kill timer interval
         TIMEUSED STORADR=STOPTM,CPU=MIC,LINKAGE=SYSTEM  Save ending  ->
                                                          time
         LG    1,STOPTM            Compute time used in KEEPITUP
         SG    1,STARTTM
         SR    0,0                 Convert micro seconds to
         D     0,=F'10000'          1/100th seconds
         CVD   1,DWORK             Convert time to packed decimal
         MVC   TUSED,TPATT         Copy edit pattern to work area
         LA    1,TUSED+3           Compute addr of the default first  ->
                                    significant digit
         EDMK  TUSED,DWORK+5       Convert paxcked decimal to digits
         LR    3,1                 Copy addr of the first significant ->
                                    digit to reg 3
         LA    2,TUSED+L'TUSED     Compute addr of the end of the     ->
                                    CPU used time
         SR    2,3                 Compute number of digits in CPU    ->
                                    used time
*        LA    1,FMT04             Compute address of the format
*        BAS   14,TPUTMSG          Generate & write the last message
         DROP  13
EXIT     L     13,4(,13)           Load address of the higher save area
         LA    0,WASIZE            Free the work area
         FREEMAIN RU,LV=(0),A=(11)
         RETURN (14,12),T,RC=0     Restore registers & return to TMP
         EJECT
         CNOP  0,8
TPUTMSG  BASR  15,0                Store current address in reg 15
         SAVE  (14,1),,TPUTMSG     Save registers
         LA    15,72(,13)          Add new save area
         ST    13,4(,15)            to the save area chain
         ST    15,8(,13)
         LR    13,15               Prepare new save area pointer
         LA    0,FMTWORK           Load MINIFMT work area address
         L     15,=V(MINIFMT)      Prepare the message
         CALL  (15)
         LA    15,4                Load size of an RDWW
         LH    0,0(,1)             Load the message length
         AR    1,15                Compute address of the msg text
         SR    0,15                Compute length of the message text
         BNP   TPUTM100            Oops
         TPUT  (1),(0),R           Write the message
TPUTM100 L     13,4(,13)           Load address of the higher save area
         RETURN (14,1)             Restore registers & return
         EJECT
         PUSH  USING
         DROP  ,
* Timer interval completion exit, post the timer ECB.  This code
* is copied to the work area and executed in the work area
         CNOP  0,8
ITIMEUPX BASR  3,0
         USING *,3
         POST  ECBX,0
         SVC   3
ECBX     DC    F'0'
ITIMESZ  EQU   *-ITIMEUPX
         SPACE 5
* STAX exit routine, post the STAX ECB.
* This code is copied to the work area and executed in the work area.
         CNOP  0,8
STAXXIT  BASR  3,0
         USING *,3
         POST  STAXECB,0
         SVC   3
STAXECB  DC    F'0'
STAXSIZE EQU   *-STAXXIT
         DROP  ,
         EJECT
         CNOP  0,8
         USING *,15                Establish addressability
TESTWAIT SAVE  (14,1),,*           Save registers
         L     1,0(,1)             Load address of the PDE
         LH    14,4(,1)            Load length of the wait time text
         BCTR  14,0                Reduce length by 1
         L     1,0(,1)             Load address of the wait time text
         EX    14,TSTIPACK         Convert text to decimal
         CVB   0,64(,13)           Convert wait time to binary
         LTR   0,0                 WAITTIME(0)
         BZ    TSTIRC4             No, no
         MHI   0,60                Convert wait time to seconds
         L     14,CVTPTR           Load address of the CVT
         L     14,CVTSMCA-CVTMAP(,14)  Load address of the SMCA
         ICM   1,B'1111',SMCAJWT-SMCABASE(14)  Load JWT
         BZ    TSTIRC0             Br if JWT = 0
         CR    0,1                 Compare wait time w/ JWT
         BH    TSTIRC4             Br if wait time > JWT
         B     TSTIRC0             Wsit time is OK
         SPACE 5
         CNOP  0,8
         USING *,15                Establish addressability
TESTINTV SAVE  (14,1),,*           Save registers
         L     1,0(,1)             Load address of the proposed       ->
                                    interval time PDE
         LH    14,4(,1)            Load proposed length
         BCTR  14,0                Reduce proposed length by 1
         L     1,0(,1)             Load address of proposed time
         EX    14,TSTIPACK         Convert proposed time to decimal
         CVB   14,64(,13)          Convert proposed time to binary
         LTR   14,14               INTERVAL(0)?
         BZ    TSTIRC4             Yes
         CHI   14,24*60            Test if greater than 24 hours
         BH    TSTIRC4             Oops
         SR    0,0                 Set reg 0 = 0
         CHI   14,60               Compare minutes with 60
         BNH   TSTI60              Br if minutes <= 60
         LHI   1,24*60             Load minutes in 24 hours
         B     TSTIREM
TSTI60   LHI   1,60                Load minutes in 1 hour
TSTIREM  DR    0,14                Divide max time by proposed time
         LTR   0,0                 Test the remainder
         BNZ   TSTIRC4             Not 0, reject the proposed time
TSTIRC0  RETURN (14,1),RC=0        Proposed time is OK
TSTIRC4  RETURN (14,1),RC=4        Proposed time is not valid
TSTIPACK PACK  64(8,13),0(*-*,1)   ** EX only **
         POP   USING
         DC    0D'0'
         LTORG ,
         SPACE 1
* MINIFMT formats
C0       EQU   X'C0'               Define mask for variable + S con
FMT01    DC    AL1(L'FMT01A)
FMT01A   DC    C'IT IS '
         DC    AL.2(3),AL.6(0),AL1(L'DAYOFWEEK,0),SL2(0(4))
         DC    AL1(2),C', '
         DC    AL.2(3),AL.6(4),AL1(7,4)
         DC    AL1(2),C' ('
         DC    AL.2(3),AL.6(4),AL1(9,0)
         DC    AL1(1),C'.'
         DC    AL.2(3),AL.6(4),AL1(14,0)
         DC    AL1(2),C') '
         DC    AL1(C0+1,L'DAYS,0),SL2(DAYS)
         DC    AL1(3),CL3' D '
         DC    AL1(C0+1,L'HOURS,0),SL2(HOURS)
         DC    AL1(3),CL3' H '
         DC    AL1(C0+1,L'MINUTES,0),SL2(MINUTES)
         DC    AL1(3),C' M '
         DC    AL1(C0+1,L'SECONDS,0),SL2(SECONDS)
         DC    AL1(2),C' S',X'FF'
         SPACE 1
         USING SMCABASE,2
         USING TIOT,3
FMT02    DC    AL1(L'FMT02A)
FMT02A   DC    C'KEEPITUP RUNNING '
*FMT02A   DC    C'KEEPITUP RUNNING ON '
*        DC    AL.2(3),AL.6(0),AL1(L'SMCASID,0),SL2(SMCASID)
         DC    AL1(L'FMT02B)
*FMT02B   DC    C' FOR '
FMT02B   DC    C'FOR '
         DC    AL.2(3),AL.6(0),AL1(L'TIOCNJOB,0),SL2(TIOCNJOB)
         DC    AL1(L'FMT02C)
FMT02C   DC    C' STARTED AT '
         DC    AL.2(3),AL.6(4),AL1(0,2)
         DC    AL1(L'FMT02D)
FMT02D   DC    C' ON '
         DC    AL.2(3),AL.6(0),AL1(L'DAYOFWEEK,0),SL2(0(4))
         DC    AL1(1),C' '
         DC    AL.2(3),AL.6(4),AL1(12,0)
         DC    AL1(1),C' '
         DC    AL.2(3),AL.6(4),AL1(13,0),X'FF'
         DROP  2,3
         SPACE 1
FMT03    DC    AL1(L'FMT03A)
FMT03A   DC    C'KEEPITUP V2L4 &SYSDATE &SYSTIME',X'FF'
         SPACE 1
*        USING SAVE,13
*FMT04    DC    AL1(L'FMT04A)
*FMT04A   DC    C'KEEPITUP USED '
*        DC    AL.2(3),AL.6(3),AL1(0,0),SL2(R2+3)
*        DC    AL.2(3),AL.6(0),AL1(0,0),SL2(0(3))
*        DC    AL1(L'FMT04B)
*FMT04B   DC    C' CPU SECONDS',X'FF'
*        DROP  13
         SPACE 1
         USING SMCABASE,2
         USING TIOT,3
FMT05    DC    AL1(L'FMT05A)
FMT05A   DC    C'KEEPITUP RUNNING ON '
         DC    AL.2(3),AL.6(0),AL1(L'SMCASID,0),SL2(SMCASID)
         DC    AL1(L'FMT05B)
FMT05B   DC    C' FOR '
         DC    AL.2(3),AL.6(0),AL1(L'TIOCNJOB,0),SL2(TIOCNJOB)
         DC    AL1(L'FMT05C)
FMT05C   DC    C' STARTED AT '
         DC    AL.2(3),AL.6(4),AL1(0,2)
         DC    AL1(L'FMT05D)
FMT05D   DC    C' ON '
         DC    AL.2(3),AL.6(0),AL1(L'DAYOFWEEK,0),SL2(0(4))
         DC    AL1(1),C' '
         DC    AL.2(3),AL.6(4),AL1(12,0)
         DC    AL1(1),C' '
         DC    AL.2(3),AL.6(4),AL1(13,0)
         DC    AL1(L'FMT05G)
FMT05G   DC    C'  INTERVAL('
         DC    AL.2(3),AL.6(1),AL1(L'IINTERVAL,0),SL2(IINTERVAL)
         DC    AL1(L'FMT05H)
FMT05H   DC    C')  MAXWAIT('
         DC    AL.2(3),AL.6(1),AL1(L'IMAXWAIT,0),SL2(IMAXWAIT)
         DC    AL1(1),C')',X'FF'
         DROP  2,3
         SPACE 1
DAYOFWEEK DC   C'SUNDAY   '
         DC    C'MONDAY   '
         DC    C'TUESDAY  '
         DC    C'WEDNESDAY'
         DC    C'THURSDAY '
         DC    C'FRIDAY   '
         DC    C'SATURDAY '
         SPACE 1
*                  5 6  7
*                 0----+-
TPATT    DC    0C' NNN.NN',C' ',X'202120',C'.',X'2020'
*                 0----+-
EPATT    DC    0C' NNN:NN',C' ',X'202120',C':',X'2020'
         DC    0D'0'
LINKPARS LINK  SF=L,EP=IKJPARS
         DC    0D'0'
         EJECT
         PUSH  PRINT
         PRINT NOGEN
TSOPCL   IKJPARM DSECT=TSOPDL
PDLVER   IKJKEYWD
         IKJNAME VERSION
PDLTEST  IKJKEYWD
         IKJNAME TEST
PDLWAITK IKJKEYWD DEFAULT='MAXWAIT(5)'
         IKJNAME MAXWAIT,SUBFLD=PDLWAITS
PDLINTVK IKJKEYWD DEFAULT='INTERVAL(60)'
         IKJNAME INTERVAL,SUBFLD=PDLINTVS
PDLHDR   IKJKEYWD
         IKJNAME LONGHEADER
         IKJNAME LONGHDR
         IKJNAME LH
PDLINTVS IKJSUBF
PDLINTV  IKJIDENT 'INTERVAL',FIRST=NUMERIC,OTHER=NUMERIC,MAXLNTH=4,   ->
               PROMPT='MINUTES BETWEEN SCREEN UPDATES',               ->
               VALIDCK=TESTINTV
PDLWAITS IKJSUBF
PDLWAIT  IKJIDENT 'MAXIMUM WAIT TIME',FIRST=NUMERIC,OTHER=NUMERIC,    ->
               MAXLNTH=2,PROMPT='MAXIMUM WAIT INTERVAL IN MINUTES',   ->
               VALIDCK=TESTWAIT
         IKJENDP
TSOPCL   CSECT
TSOPCL   RMODE ANY
         DC    0D'0'
         CVT   DSECT=YES
         IEESMCA
         IKJTCB
         IEFTCT
         IEFJMR
TIOT     DSECT
         IEFTIOT1
         IKJCPPL ,
RCBUF    EQU   ((CPPLCBUF-CPPL)/4)+6
*RPSCB    EQU   ((CPPLPSCB-CPPL)/4)+6
RECT     EQU   ((CPPLECT-CPPL)/4)+6
RUPT     EQU   ((CPPLUPT-CPPL)/4)+6
         IKJPPL ,
SAVEAREA DS    (2*9)D'0'           2 72 byte register save areas
STARTTM  DS    FD
STOPTM   DS    FD
NOW      DS    2F
FMTWORK  DS    XL200               MINIFMT work area
ITIMEUP  DS    XL(ITIMESZ),0F
STAXEXIT DS    XL(STAXSIZE),0D
STAXPARM STAX  MF=L
EPARM    CALL  ,(*-*,*-*,*-*),MF=L SMFETIME parm list
ELAPSED  DS    F                   Session time returned by SMDETIME
ECBLIST  DS    2A(0)
TSOECB   DS    F
PDLPTR   DS    A
INTERVAL DS    F
IINTERVAL DS   F
WAITTIME DS    F                   STIMER macro wait interval
MAXWAIT  DS    F
IMAXWAIT DS    F
*TERMPARM GTTERM MF=L
*SCRSIZE  DC    AL2(0)
SCRSIZE2 DC    AL2(0)
SECONDS  DS    F
MINUTES  DS    F
HOURS    DS    F
DAYS     DS    F
         SPACE 1
STARTBUF DS    2AL2(0),CL160
TUSED    DS    CL(L'TPATT)
SWITCH   DS    AL1
VER      EQU   X'01'
TEST     EQU   X'02'
LONGHDR  EQU   X'04'
         DS    0D
WASIZE   EQU   *-PPL
         SPACE 2
SAVE     DSECT
         DS    F                   Reserved
HSA      DS    A                   -> Higher save area
LSA      DS    A                   -> Lower save area
R14      DS    F                   Register 14
R15      DS    F                             15
R0       DS    F                              0
R1       DS    F                               1
R2       DS    F                                2
R3       DS    F                                 3
R4       DS    F                                  4
R5       DS    F                                   5
R6       DS    F                                    6
R7       DS    F                                     7
R8       DS    F                                      8
R9       DS    F                                       9
R10      DS    F                                        10
DWORK    DS    0D
R11      DS    F                                         11
R12      DS    F                                          12
         POP   PRINT
         END   KEEPITUP
MINIFMT  TITLE '                                  MINIFMT - A Message G>
               enerator'
***********************************************************************
*                                                                     *
* Title -- MINIFMT                                                    *
*                                                                     *
* Function / Operation -- MINIFMT is a message generator program.  It *
*   is a proper superset of MICROFMT; all valid MICROFMT formats will *
*   produce the same results as MICROFMT.  Additional formatting      *
*   includes date and time formats, formats to translate the record   *
*   formats included with the DCB and Format 1 DSCBs, the DSORG in    *
*   the DCB and Format 1 DSCBs, and tabs and multiple space inserts.  *
*                                                                     *
* Status / Change Level --                                            *
*   V1L5 -- September 2016                                            *
*    - CNVTBIN rewritten to improve performance and reduce storage    *
*      foot print                                                     *
*      - Fewer registers saved / restored                             *
*      - One divide / multiply pair eliminated                        *
*      - Last multiply of hours by 1,000,000 changed to               *
*        two MHI reg,1000 to eliminate a SR and the storage for       *
*        F'1000000'.                                                  *
*      - Method to strip the packed decimal sign from the result      *
*        simplified.                                                  *
*    - Copyright added to SAVE macro                                  *
*   V1L4 -- January 2015                                              *
*    - Added LJUSTX external function to left justify the contents    *
*      of a text data srea.                                           *
*   V1L3 -- November 2014                                             *
*    - Add formst 10, a binary to decimal conversion that inserts ,   *
*      characters between every 3 digits, e.g., 1,035 rather than     *
*      1035, to make large numbers easier to read.                    *
*   V1L2 -- June 2010                                                 *
*    - Hex conversion for fields containing more than 7 bytes not     *
*      being done correctly                                           *
*   V1L1 -- June 2010                                                 *
*    - Blank not being inserted between the date and time for format  *
*      codes 4 and 5 if both a date code and time code are specified  *
*    - Tab problem                                                    *
*   V1L0 -- April 2010                                                *
*                                                                     *
* Calling sequence --                                                 *
*            LA    0,FMTWORK                                          *
*            LA    1,FORMAT                                           *
*            L     15,=V(MINIFMT)      MINIFMT CAN ALSO BE CALLED     *
*            BALR  14,15               USING BRAS OR BRASL            *
*            ...                                                      *
*   FMTWORK  DC    XL200'0'                                           *
*   FORMAT   DC    -- Format Specifications --                        *
*                                                                     *
*   Returns -- Address of generated output line in register 1.        *
*     All other registers are returned unchanged                      *
*                                                                     *
* Format Specification --                                             *
*   A format consists of two or more field specifications.  There are *
*   three types of field specifications --                            *
*   - End of format -- X'FF' or X'00'                                 *
*   - In line text -- AL1(length),C'in line text'                     *
*     Length can be 1 to 127                                          *
*   - Data conversion -- These data conversions are provided.         *
*     . Character, for data areas from 1 to 255 bytes.                *
*     . Binary to decimal, of unsigned 1, 2 and 3 byte fields, and    *
*       signed 4 byte fields                                          *
*     . Binary to hexadecimal, of data areas from 1 to 255 bytes. Two *
*       output bytes for each input byte                              *
*     . Insert blanks.                                                *
*     . Format system date and time                                   *
*     . Format date and time using a TIME DEC formatted date and      *
*       time.                                                         *
*     . Provide a tabbing capability                                  *
*     Each data conversion is specified as a multiple byte format --  *
*     Offset  Bit  Value Purpose                                      *
*        0     0     1 -- Indicates data conversion                   *
*        0     1     0 -- Address specified as an in-line 4 byte      *
*                         address constant                            *
*        0     1     1 -- Address specified as a 2 byte S type        *
*                         address                                     *
*                         The S-con base register can be registers 2  *
*                         through 13.  Since registers 14, 15, 0 and  *
*                         are used as link registers, their use in    *
*                         an S-con is limited.                        *
*        0    2-7    0 -- Copy text string to output line             *
*                    1 -- Translate 1 to 4 byte binary to decimal     *
*                    2 -- Translate 1 to 255 byte binary to           *
*                         hexadecimal digits                          *
*                    3 -- Provide input length for an undefined       *
*                         text or  hexadecimal conversion             *
*                    4 -- Format the system date and time.  The       *
*                         input length byte specifies the date        *
*                         format, the output length byte specifies    *
*                         the time format.  MINIFMT obtains the       *
*                         system date the first time this format is   *
*                         encountered.                                *
*                    5 -- Format the date and time in a TIME DEC      *
*                         storage area                                *
*                    6 -- Insert blanks                               *
*                    7 -- Tab.  A tab to a position higher than the   *
*                         current end of line inserts blanks.  The    *
*                         position is relative to the first byte in   *
*                         the line.                                   *
*                    8 -- Translate DCBRECFM/DS1RECFM                 *
*                    9 -- Translate DCBDSORG/DS1DSORG                 *
*                   10 -- Tranalate 1 to 4 byte binary to decimal     *
*                         using an alternate format, nnn,nnn rather   *
*                         than nnnnnn                                 *
*        1    0-7    Input length.                                    *
*                    For codes 4 and 5, this byte contains a date     *
*                    format code --                                   *
*                     1 -- yyyy/mm/dd                                 *
*                     2 -- yy/mm/dd                                   *
*                     3 -- mm/dd/yyyy                                 *
*                     4 -- mm/dd/yy                                   *
*                     5 -- yyyy month dd                              *
*                     6 -- yy month dd                                *
*                     7 -- month dd, yyyy                             *
*                     8 -- yyyy                                       *
*                     9 -- yy                                         *
*                    10 -- mm    (Month as a two digit number)        *
*                    11 -- mmm   (Abbreviated month name)             *
*                    12 -- month (Full month name)                    *
*                    13 -- dd    (Day of month)                       *
*                    14 -- ddd   (Day of year)                        *
*                                                                     *
*                    Date codes that insert a 2 digit year makes      *
*                    your program Y2K conpatible if it is Y2K         *
*                    compliant in all other aspects                   *
*                                                                     *
*        2    0-7    Output length.  Not used for hex conversion.  If *
*                    0 is specified, for binary to decimal conversion *
*                    the output length is the length of the converted *
*                    number, for character conversion the output      *
*                    length is the input length with trailing blanks  *
*                    removed                                          *
*                                                                     *
*                    For codes 4 and 5, this byte contains a time     *
*                    format code --                                   *
*                     1 -- hh:mm       (24 hour clock)                *
*                     2 -- hh:mm xM    (xM is AM or PM)               *
*                     3 -- hh:mm:ss    (24 hour clock)                *
*                     4 -- hh:mm:ss xM (xM is AM or PM)               *
*                                                                     *
*                    If a date code and a time code are both          *
*                    present, a blank appears between the date and    *
*                    time.                                            *
*                                                                     *
*        3           Data address, as either a 2-bye S type address   *
*                    or a 4 byte address constant.                    *
*                                                                     *
* Attributes -- MINIFMT is reenterable, refreshable and reusable.  It *
*   operates in any key, problem or supervisor state.  It is  not     *
*   intended to operate in AR mode or the 64-bit addressing mode.  It *
*   will operate in the 24-bit addressing mode if the format, work    *
*   area, and any data referenced in the format is in the 24-bit      *
*   residence area.                                                   *
*                                                                     *
***********************************************************************
         SPACE 5
MINIFMT  RSECT
MINIFMT  AMODE ANY
MINIFMT  RMODE ANY
         PUSH  PRINT
         PRINT NOGEN
         DCBD  DSORG=QS,DEVD=DA    DEFINE DCB SYMBOLS
         POP   PRINT
MFMTWORK DSECT
MFMTWWRK DS    D                   DOUBLE WORD ALIGNED 8 BYTE WORK AREA
MFMTWDT  DS    2F                  SYSTEM DATE AND TIME
MFMTWEWK DS    0C' 999999999999999'
MFMTWLNG DS    C' 999,999,999,999,999'
MFMTWLEN DS    AL1                 LENGTH FROM FORMAT 3
MFMTWFLG DS    AL1                 NON-ZERO IF SYSTEM DATE AND TIME   ->
                                    STORED IN MFMFWDT
MFMTSAVE DS    AL1,0F
MFMTWLNE DS    2AL2                GENERATED OUTPUT LINE
MINIFMT  RSECT
         BASR  15,0                STORE CURRENT ADDRESS IN REG 15
         USING *,12                ESTABLISH PROGRAM BASE REGISTER
         USING MFMTWORK,11         ESTABLISH WORK AREA ADDRESSABILITY
*        SAVE  (14,12),,MINIFMT-V1L4-&SYSDATE-&SYSTIME  SAVE REGISTERS
         SAVE  (14,12),,'MINIFMT V1L5 &SYSDATE &SYSTIME  Copyright (c) >
               2010, 2014-2016 J. Stephen Myers'
         LR    12,15               COPY ENTRY POINT ADDRESS TO REG 12
         LR    11,0                COPY WORK AREA ADDRESS TO REG 11
         MVI   MFMTWFLG,0          INDICATE SYSTEM DATE AND TIME NOT  ->
                                    IN WORKAREA
         LR    3,1                 COPY ADDRESS OF FORMAT TO REG 3
         LA    14,MFMTWLNE+4       LOAD START OF TEXT OUTPUT
MFMT0100 CLI   0(3),X'FF'          TEST IF END OF FORMAT
         JE    MFMT7600
         CLI   0(3),0
         JE    MFMT7600
         TM    0(3),X'80'          TEST IF DATA CONVERSION
         JO    MFMT0200            BR IF SO
         SR    15,15               SET REG 15 = 0
         IC    15,0(,3)            LOAD LENGTH OF IN-LINE CHARACTER   ->
                                    STRING
         LA    0,1(,3)             LOAD START OF IN-LINE CHARACTER    ->
                                    STRING
         LR    1,15                COPY LENGTH TO REG 1
         MVCL  14,0                COPY IN-LINE CHARACTER STRING TO   ->
                                    NEW LINE
         LR    3,0                 COPY START OF NEXT FORMAT TO REG 3
         J     MFMT0100            GO CHECK THE NEXT FORMAT
MFMT0200 IC    15,0(,3)            LOAD FORMAT TYPE
         N     15,=A(X'3F')        ISOLATE TYPE
         CHI   15,10               COMPARE WITH MAX
         JH    MFMT7500            BR TO FORMAT ERROR
         SLL   15,2                MULTIPLY TYPE BY 4
         B     *+4(15)             BR TO JUMP TABLE ENTRY
         J     MFMT0400            TYPE 0 - CHARACTER
         J     MFMT0800            TYPE 1 - BINARY TO DECIMAL
         J     MFMT1200            TYPE 2 -BINARY TO HEXADECIMAL DIGITS
         J     MFMT0300            TYPE 3 - SAVE LENGTH FOR TYPES 0 & 2
         J     MFMT1700            TYPE 4 - FORMAT SYSTEM DATE AND TIME
         J     MFMT1900            TYPE 5 - FORMAT DATE AND TIME
         J     MFMT6500            TYPE 6 - INSERT BLANKS
         J     MFMT7300            TYPE 7 - TAB
         J     MFMT6600            TYPE 8 - TRANSLATE DCBRECFM
         J     MFMT6900            TYPE 9 - TRANSLATE DCBDSORG
         J     MFMT0810            TYPE 10 - ALTERNATE TYPE 2
*        J     MFMT7500            TYPE 11 NOT SUPPORTED
*        J     MFMT7500            TYPE 12 NOT SUPPORTED
*        J     MFMT7500            TYPE 13 NOT SUPPORTED
*        J     MFMT7500            TYPE 14 NOT SUPPORTED
*        J     MFMT7500            TYPE 15 NOT SUPPORTED
MFMT0300 LA    1,3(,3)             LOAD ADDRESS OF DATA ADDRESS
         BRAS  15,MFMT5900         GET THE ADDRESS
         MVC   MFMTWLEN,0(4)       SAVE THE LENGTH
         J     MFMT0100            GO DO THE NEXT FORMAT
MFMT0400 LA    1,3(,3)             LOAD ADDRESS OF DATA ADDRESS
         SR    5,5                 SET REG 5 = 0
         SR    6,6                 SET REG 6 = 0
         ICM   5,B'0001',1(3)      LOAD THE INPUT LENGTH
         JNZ   *+L'*+4             BR IF INPUT LENGTH IS DEFINED
         IC    5,MFMTWLEN          LOAD SAVED LENGTH
         IC    6,2(,3)             LOAD THE OUTPUT LENGTH
         BRAS  15,MFMT5900         GET THE ADDRESS
         LTR   15,6                TEST IF OUTPUT LENGTH IS SPECIFIED
         JZ    MFMT0500            BR IF NOT
         LR    0,4                 COPY START OF DATA TO REG 0
         LR    1,5                 COPY INPUT LENGTH TO REG 1
*        ICM   1,B'1000',=C' '     LOAD FILL CHARACTER
         O     1,=AL1(C' ',0,0,0)  ADD FILL CHARACTER
         MVCL  14,0                COPY DATA TO OUTPUT AREA
         J     MFMT0100            GO DO THE NEXT FORMAT
MFMT0500 LA    15,0(5,4)           PUT END OF INPUT AREA INTO REG 15
MFMT0600 AHI   15,-1               BACKUP 1 BYTE
         CR    15,4                TEST IF START OF DATA
         JE    MFMT0700            BR IF SO
         CLI   0(15),C' '          TEST IF TRAILING BLANK
         JE    MFMT0600            BR IF SO
MFMT0700 LA    1,1(,15)            SET REG 1 TO END OF INPUT
         SR    1,4                 COMPUTE ACTUAL INPUT LENGTH
         LR    0,4                 COPY START OF INPUT TO REG 0
         LR    15,1                COPY LENGTH TO REG 15
         MVCL  14,0                COPY TEXT TO OUTPUT LINE
         J     MFMT0100            GO DO THE NEXT FORMAT
MFMT0800 DC    0H'0'
MFMT0810 MVC   MFMTSAVE,0(3)       SAVE THE ENTRY CODE
         NI    MFMTSAVE,X'3F'      DISCARD THE 2 HIGH ORDER BITS
         LA    1,3(,3)             LOAD ADDRESS OF DATA ADDRESS
         SR    5,5                 SET REG 5 = 0
         SR    6,6                 SET REG 6 = 0
         IC    5,1(,3)             LOAD THE INPUT LENGTH
         IC    6,2(,3)             LOAD THE OUTPUT LENGTH
         BRAS  15,MFMT5900         GET THE ADDRESS
         SLL   5,2                 MULTIPLY LENGTH BY 4
         SR    15,15               SET REG 15 = 0
         EX    0,MFMT6400(5)       LOAD THE BINARY VALUE
         CVD   15,MFMTWWRK         CONVERT MFMT0800 VALUE TO PACKED   ->
                                    DECIMAL
         CLI   MFMTSAVE,1          TEST FORMAT CODE
         JE    MFMT0820            BR IF FORMAT 1
         MVC   MFMTWLNG,MFMT8310   COPY THE ALTERNATE EDIT MASK
         LA    1,MFMTWLNG+L'MFMTWLNG-1  LOAD ADDR OF THE DEFAULT 0
         EDMK  MFMTWLNG,MFMTWWRK   EDIT THE NUMBER
         J     MFMT0830
MFMT0820 MVC   MFMTWEWK,MFMT8300   COPY EDIT MASK TO WORK AREA
         LA    1,MFMTWEWK+L'MFMTWEWK-1
         EDMK  MFMTWEWK,MFMTWWRK   CONVERT PACKED DECIMAL VALUE TO    ->
                                    DECIMAL DIGITS
MFMT0830 LTR   15,15               TEST VALUE
         JNM   MFMT0900            BR IF VALUE IS +
         AHI   1,-1                BACKUP START OF NUMBER BY 1
         MVI   0(1),C'-'           INSERT A MINUS SIGN
MFMT0900 LR    0,1                 COPY START OF VALUE TO REG 0
         LA    1,MFMTWEWK+L'MFMTWEWK  LOAD END OF VALUE
         CLI   MFMTSAVE,1          ALTERNATE FORMAT?
         JE    *+L'*+4             BR IF NOT
         LA    1,MFMTWLNG+L'MFMTWLNG  LOAD ALTERNATE END
         SR    1,0                 COMPUTE LENGTH OF NUMBER
         LTR   6,6                 TEST OUTPUT LENGTH
         JZ    MFMT1100            BR IF 0
         CR    6,1                 COMPARE OUTPUT LENGTH WITH MAX
         JNL   MFMT1000            BR IF NUMBER WILL FIT IN FIELD
         LR    15,6                COPY LENGTH TO REG 15
         L     1,=AL1(C'*',0,0,0)  LOAD FILL CHARACTER
         MVCL  14,0                INSERT *S IN THE OUTPUT FIELD
         J     MFMT0100            GO DO THE NEXT FORMAT
MFMT1000 LR    5,14                SAVE ADDRESS OF OUTPUT
         L     7,=AL1(C' ',0,0,0)  LOAD FILL CHARACTER
         LR    15,6                COPY FIELD LENGTH TO REG 15
         MVCL  14,6                CLEAR THE OUTPUT FIELD
         LR    14,5                COPY START OF OUTPUT FIELD TO REG 14
         LR    15,6                COPY OUTPUT FIELD LENGTH TO REG 15
         SR    15,1                COMPUTE NUMBER OF LEADING BLANKS
         AR    14,15               COMPUTE START OF NUMBER IN OUTPUT
MFMT1100 LR    15,1                COPY LENGTH TO REG 15
         MVCL  14,0                COPY CONVERTED VALUE TO OUTPUT
         J     MFMT0100            GO DO THE NEXT FORMAT
* TRANSLATE INPUT BINARY DATA TO HEXADECIMAL DIGITS
* JUST THE INPUT LENGTH IS USED, AN OUTPUT LENGTH IS IGNORED
MFMT1200 LA    1,3(,3)             LOAD ADDRESS OF ADDRESS
         SR    5,5                 SET REG 5 = 0
         ICM   5,B'0001',1(3)      LOAD THE INPUT LENGTH
         JNZ   *+L'*+4             BR IF INPUT LENGTH IS DEFINED
         IC    5,MFMTWLEN          LOAD SAVED INPUT LENGTH
         BRAS  15,MFMT5900         GET THE ADDRESS
MFMT1300 CHI   5,7                 TEST REMINING LENGTH
         JNH   MFMT1400            BR IF 7 OR FEWER BYTES REMAIN
         UNPK  0(15,14),0(8,4)     TRANSLATE 7 BYTES TO HEX DIGITS
         TR    0(14,14),MFMT8200
         AHI   14,14               BUMP THE OUTPUT POINTER
         AHI   4,7                 BUMP THE INPUT POINTER
         AHI   5,-7                REDUCE REMAINING LENGTH BY 7
         J     MFMT1300            GO DO THE NEXT GROUP
MFMT1400 LR    1,5                 COPY REMAINING LENGTH TO REG 1
         SLL   1,5                 GET OUTPUT LENGTH
         OR    1,5                 ADD IN INPUT LENGTH
         EX    1,MFMT1500          TRANSLATE LAST GROUP OF BYTES
         SRL   1,4                  TO HEXADECIMAL DIGITS
         EX    1,MFMT1600
         AR    14,1                UPDATE THE OUTPUT POINTER
         J     MFMT0100            GO CHECK THE NEXT FORMAT
MFMT1500 UNPK  0(*-*,14),0(*-*,4)  ** EXECUTE ONLY **
MFMT1600 TR    0(*-*,14),MFMT8200  ** EXECUTE ONLY **
* FORMAT SYSTEM DATE AND TIME
MFMT1700 CLI   MFMTWFLG,0          TEST IF SYSTEM TIME OBTAINED
         JNE   MFMT1800            BR IF SO
         ST    14,MFMTWDT          SAVE REG 14
         TIME  DEC                 GET THE SYSTEM DATE AND TIME
         L     14,MFMTWDT          RESTORE REG 14
         STM   0,1,MFMTWDT         STORE THE DATE AND TIME
         MVI   MFMTWFLG,255        INDICATE DATE AND TIME IN WORK AREA
MFMT1800 SR    5,5                 SET REG 5 = 0
         SR    6,6                 SET REG 6 = 0
         IC    5,1(,3)             LOAD THE DATE CODE
         IC    6,2(,3)             LOAD THE TIME CODE
         LA    3,3(,3)             LOAD ADDRESS OF THE NEXT FORMAT
         LA    4,MFMTWDT           LOAD ADDRESS OF THE DATE AND TIME
         J     MFMT2000            BR TO DATE/TIME COMMON CODE
* FORMAT DATE AND TIME FROM STORAGE REPRESENTING REG 0 AND REG 1
* AFTER EXECUTING A TIME DEC MACRO
MFMT1900 SR    5,5                 SET REG 5 = 0
         SR    6,6                 SET REG 6 = 0
         IC    5,1(,3)             LOAD THE DATE CODE
         IC    6,2(,3)             LOAD THE TIME CODE
         LA    1,3(,3)             LOAD THE ADDRESS OF THE ADDRESS
         BRAS  15,MFMT5900         GET THE DATA AREA ADDRESS
MFMT2000 LTR   5,5                 TEST IF DATE WANTED
         JZ    MFMT5010            BR IF NOT
         ICM   9,B'1111',4(4)      LOAD THE DATE
         JNZ   MFMT2010            BR IF DATE IS PRSENT
         SR    1,1                 SET DAY OF MONTH = 0
         SR    8,8                 SET MONTH = 0
         MVC   MFMTWEWK+L'MFMTWEWK-3-4(4),=C'0000' SET YEAR IN MFMTWEWK
         J     MFMT2210            AND CONTINUE
MFMT2010 ZAP   MFMTWWRK,4(4,4)     COPY THE DATE TO THE WORK AREA
         CVB   9,MFMTWWRK          CONVERT THE DATE TO BINARY
         A     9,=F'1900000'       CONVERT THE YEAR FROM CYY TO A     ->
                                    TRUE YEAR
         CVD   9,MFMTWWRK          CONVERT YYYYDDD TO PACKED DECIMAL
         UNPK  MFMTWEWK,MFMTWWRK   CONVERT YYYYDDD TO DECIMAL.  THE   ->
                                    DDD IS NOT USABLE, BUT THE YYYY IS
         SR    8,8                 SET REG 8 = 0
         D     8,=F'1000'          ISOLATE THE YEAR
         LR    1,8                 COPY THE DAY OF YEAR TO REG 1
         SR    8,8                 SET REG 8 = 0
         LR    0,9                 COPY YEAR TO REG 0
         N     0,=A(B'11')         TEST IF YEAR DIVISIBLE BY 4
         JNZ   MFMT2100            BR IF NOT, IT CAN'T BE A LEAP YEAR
         D     8,=F'100'           DIVIDE YEAR BY 100
         LTR   8,8                 TEST REMAINDER
         JNZ   MFMT2200            YEAR IS NOT A CENTURY YEAR, SO IT  ->
                                    MUST BE A LEAP YEAR
         N     9,=A(B'11')         TEST IF YEAR CAN BE DIVIDED BY 400
         JZ    MFMT2200            CENTURY YEAR IS A LEAP YEAR
MFMT2100 CHI   1,31+28             COMPARE DAY OF YEAR WITH FEB 28
         JNH   MFMT2200            BR IF DAY OF YEAR DOES NOT HAVE    ->
                                    TO BE ADJUSTED
         AHI   1,1                 PRETEND DAY OF YEAR IS IN A LEAP   ->
                                    YEAR
MFMT2200 SR    8,8                 SET REG 8 = 0
         IC    8,MFMT8600(1)       LOAD THE MONTH FOR THE DAY OF YEAR
         SLL   8,1                 MULTIPLY MONTH BY 2
         SH    1,MFMT8500(8)       SUBTRACT DAY OF YEAR FOR THE 1ST   ->
                                    DAY OF THE MONTH FROM DAY OF YEAR
         SRL   8,1                 RESET MONTH TO "NORMAL" FORM
* DAY OF MONTH IS IN REG 1, MONTH IS IN REG 8, AND YEAR IN
* CHARACTER FORM IS IN MFMTWEWK
MFMT2210 SLL   5,2                 MULTIPLY DATE CODE BY 4
         B     *(5)                BR
         J     MFMT2300             1 -- FORMAT DATE AS YYYY/MM/DD
         J     MFMT2400             2 -- FORMAT DATE AS YY/MM/DD
         J     MFMT2600             3 -- FORMAT DATE AS MM/DD/YYYY
         J     MFMT2700             4 -- FORMAT DATE AS MM/DD/YY
         J     MFMT2900             5 -- FORMAT DATE AS YYYY MONTH DD
         J     MFMT3000             6 -- FORMAT DATE AS YY MONTH DD
         J     MFMT3200             7 -- FORMAT DATE AS MONTH DD, YYYY
         J     MFMT3300             8 -- FORMAT YEAR AS YYYY
         J     MFMT3400             9 -- FORMAT YEAR AS YY
         J     MFMT3500            10 -- FORMAT MONTH AS MM (NUMERIC)
         J     MFMT3600            11 -- FORMAT MONTH AS MMM
         J     MFMT3700            12 -- FORMAT MONTH AS MONTH
         J     MFMT3710            13 -- FORMAT DAY OF MONTH AS DD
         J     MFMT3720            14 -- FORMAT DAY OF YEAR
         J     MFMT7500            15 -- INVALID
MFMT2300 ICM   15,B'1111',4(4)     LOAD THE DATE
         JNZ   MFMT2310            BR IF DATE PRESENT
         MVC   0(10,14),=CL10'--'  INDICATE MISSING DATE
         AHI   14,10               BUMP OUTPUT
         J     MFMT5000            TEST IF TIME
MFMT2310 BRAS  15,MFMT3800         COPY THE 4 DIGIT YEAR
         J     MFMT2500            AND CONTINUE
MFMT2400 ICM   15,B'1111',4(4)     LOAD THE DATE
         JNZ   MFMT2410            BR IF DATE PRESENT
         MVC   0(8,14),=CL10'--'   INDICATE MISSING DATE
         AHI   14,8                BUMP OUTPUT
         J     MFMT5000            TEST IF TIME
MFMT2410 BRAS  15,MFMT3900         COPY THE 2 DIGIT YEAR
MFMT2500 BRAS  15,MFMT4000         INSERT A /
         BRAS  15,MFMT4300         INSERT MM
         BRAS  15,MFMT4000         INSERT A /
         BRAS  15,MFMT4800         INSERT DD
         J     MFMT5000            TEST IF TIME
MFMT2600 ICM   15,B'1111',4(4)     LOAD THE DATE
         JNZ   MFMT2610            BR IF DATE PRESENT
         MVC   0(10,4),=CL10'--'   INDICATE MISSING DATE
         AHI   14,10               BUMP OUTPUT
         J     MFMT5000            TEST IF TIME
MFMT2610 BRAS  15,MFMT4300         INSERT MM
         BRAS  15,MFMT4000         INSERT A /
         BRAS  15,MFMT4800         INSERT DD
         BRAS  15,MFMT4000         INSERT A /
         BRAS  15,MFMT3800         INSERT YYYY
         J     MFMT5000            TEST IF TIME
MFMT2700 ICM   15,B'1111',4(4)     LOAD THE DATE
         JNZ   MFMT2710            BR IF DATE PRESENT
         MVC   0(8,14),=CL10'--'   INDICATE MISSING DATE
         AHI   14,8                BUMP OUTPUT
         J     MFMT5000            TEST IF TIME
MFMT2710 BRAS  15,MFMT4300         INSERT MM
         BRAS  15,MFMT4000         INSERT A /
         BRAS  15,MFMT4800         INSERT DD
         BRAS  15,MFMT4000         INSERT A /
         BRAS  15,MFMT3900         INSERT YY
         J     MFMT5000            TEST IF TIME
MFMT2800 NOPR  0                   ** NOT USED! **
MFMT2900 ICM   15,B'1111',4(4)     LOAD THE DATE
         JNZ   MFMT2910            BR IF DATE PRESENT
         MVC   0(10,4),=CL10'--'   INDICATE MISSING DATE
         AHI   14,10               BUMP OUTPUT
         J     MFMT5000            TEST IF TIME
MFMT2910 BRAS  15,MFMT3800         INSERT YYYY
         J     MFMT3100
MFMT3000 BRAS  15,MFMT3900         INSERT YY
MFMT3100 BRAS  15,MFMT4100         INSERT A SPACE
         BRAS  15,MFMT4400         INSERT LONG MONTH
         BRAS  15,MFMT4100         INSERT A SPACE
         BRAS  15,MFMT4800         INSERT DD
         J     MFMT5000            TEST IF TIME
* FORMAT MONTH DD, YYYY
MFMT3200 BRAS  15,MFMT4400         INSERT A LONG MONTH
         BRAS  15,MFMT4100         INSERT A SPACE
         BRAS  15,MFMT4800         INSERT DD
         BRAS  15,MFMT4210         INSERT C', '
         BRAS  15,MFMT3800         INSERT YYYY
         J     MFMT5000            TEST IF TIME
* FORMAT YYYY
MFMT3300 BRAS  15,MFMT3800         INSERT YYYY
         J     MFMT5000            TEST IF TIME
* FORMAT YY
MFMT3400 BRAS  15,MFMT3900         INSERT YY
         J     MFMT5000            TEST IF TIME
* FORMAT MM (NUMERIC MONTH)
MFMT3500 BRAS  15,MFMT4300         INSERT MM
         J     MFMT5000            TEST IF TIME
* FORMAT MMM (ABBREVIATED MONTH)
MFMT3600 BRAS  15,MFMT4700         INSERT MMM
         J     MFMT5000            TEST IF TIME
* INSERT FULL MONTH NAME
MFMT3700 BRAS  15,MFMT4400
         J     MFMT5000            TEST IF TIME
* INSERT DD
MFMT3710 BRAS  15,MFMT4800         INSERT DD
         J     MFMT5000            TEST IF TIME
* INSERT DDD (DAY OF YEAR)
MFMT3720 UNPK  MFMTWWRK,4(4,4)     CONVERT 0CYYDDD TO DECIMAL
         OI    MFMTWWRK+7,X'F0'    MAKE SURE THE LAST BYTE IS A DIGIT
         MVC   0(3,14),MFMTWWRK+5  COPY DDD TO OUTPUT
         AHI   14,3                UPDATE THE OUTPUT POINTER
         J     MFMT5000            TEST IF TIME
* GET THE 4 DIGIT YEAR
MFMT3800 MVC   0(4,14),MFMTWEWK+L'MFMTWEWK-3-4  COPY THE YEAR
         AHI   14,4                BUMP THE OUTPUT POINTER
         BR    15                  AND RETURN
* GET THE 2 DIGIT YEAR
MFMT3900 MVC   0(2,14),MFMTWEWK+L'MFMTWEWK-3-2  COPY THE YEAR
         AHI   14,2                BUMP THE OUTPUT POINTER
         BR    15                  AND RETURN
* INSERT A /
MFMT4000 MVI   0(14),C'/'          INSERT A /
         J     MFMT4200            UPDATE POSITION AND RETURM
* INSERT A SPACE
MFMT4100 MVI   0(14),C' '          INSERT A BLANK
MFMT4200 AHI   14,1                BUMP THE OUTPUT POINTER
         BR    15                  AND RETURN
* INSERT C', '
MFMT4210 MVC   0(2,14),=C', '      COPY C', ' TO OUTPUT
         AHI   14,2                UPDATE OUTPUT POINTER
         BR    15                  AND RETURN
* INSERT 2 DIGIT MONTH
MFMT4300 CVD   8,MFMTWWRK          CONVERT MONTH TO PACKED DECIMAL
         J     MFMT4900            CONTINUE
* INSERT FULL MONTH NAME
MFMT4400 LR    9,8                 COPY REG 8 TO REG 9
         MHI   9,9                 MULTIPLY MONTH BY LENGTH OF A MONTH
         LA    10,MFMT8700+9(9)    LOAD END OF MONTH NAME
         LA    9,MFMT8700(9)       LOAD START OF THE MONTH NAME
MFMT4500 BCTR  10,0                BACKUP 1 BYTE
         CLI   0(10),C' '          TEST FOR TRAILING BLANK
         JE    MFMT4500            BR IF TRAILING BLANK
         SR    10,9                COMPUTE LENGTH TO MOVE
         EX    10,MFMT4600         MOVE MONTH NAME TO OUTPUT LINE
         LA    14,1(10,14)         COMPUTE ADDRESS OF NEXT OUTPUT BYTE
         BR    15                  AND RETURN
MFMT4600 MVC   0(*-*,14),0(9)      ** EXECUTE ONLY **
* INSERT ABBREVIATED MONTH
MFMT4700 LR    9,8                 COPY REG 8 TO REG 9
         MHI   9,9                 MULTIPLY MONTH BY 9
         LA    9,MFMT8700(9)       COMPUTE ADDRESS OF MONTH NAME
         MVC   0(3,14),0(9)        COPY ABBREVIATED MONTH TO OUTPUT
         AHI   14,3                UPDATE OUTPUT POSITION
         BR    15                  AND RETURN
* INSERT DAY OF MONTH
MFMT4800 CVD   1,MFMTWWRK          CONVERT DAY OF MONTH TO PACKED DEC
MFMT4900 OI    MFMTWWRK+7,X'0F'    MAKE SURE THE LAST NIBBLE IS OK
         UNPK  0(2,14),MFMTWWRK    CONVERT VALUE TO DECIMAL
         AHI   14,2                BUMP THE OUTPUT POINTER
         BR    15                  AND RETURN
* TEST IF TIME WANTED
MFMT5000 LTR   6,6                 TEST TIME CODE
         JZ    MFMT0100            BR IF TIME NOT WANTED
         MVI   0(14),C' '          INSERT A BLANK
         AHI   14,1                BUMP THE OUTPUT POSITION
         J     MFMT5020
MFMT5010 LTR   6,6                 TEST TIME CODE
         JZ    MFMT0100            BR IF TIME NOT WANTED
MFMT5020 CHI   6,4                 TEST IF SUPPORTED
         JH    MFMT7500            BR IF NOT SUPPORTED
         SLL   6,2                 MULTIPLY TIME CODE BY 4
         B     *(6)                BR BASED ON TIME CODE
         J     MFMT5100             1 - HH:MM
         J     MFMT5200             2 - HH:MM AM (OR PM)
         J     MFMT5300             3 - HH:MM:SS
         J     MFMT5400             4 - HH:MM:SS AM (OR PM)
MFMT5100 MVC   MFMTWEWK(6),MFMT8400  COPY EDIT MASK TO OUTPUT
         ED    MFMTWEWK(6),0(4)    TRANSLATE PACKED DECIMAL DIGITS    ->
                                    TO DECIMAL
         MVC   0(5,14),MFMTWEWK+1  COPY TRANSLATED TIME TO OUTPUT
         AHI   14,5                BUMP THE OUTPUT POINTER
         J     MFMT0100            AND CONTINUE
MFMT5200 MVC   MFMTWEWK(6),MFMT8400  COPY EDIT MASK TO OUTPUT
         ED    MFMTWEWK(6),0(4)    TRANSLATE PACKED DECIMAL DIGITS    ->
                                    TO DECIMAL
         MVC   0(5,14),MFMTWEWK+1  COPY TRANSLATED TIME TO OUTPUT
         LA    15,5(,14)           SET REG 15
         J     MFMT5600
MFMT5300 MVC   MFMTWEWK,MFMT8400   COPY EDIT MASK TO WORK AREA
         ED    MFMTWEWK,0(4)       TRANSLATE PACKED DECIMAL DIGITS    ->
                                    TO DECIMAL
         MVC   0(L'MFMT8400-1,14),MFMTWEWK+1  COPY TRANSLATED TIME    ->
                                    TO OUTPUT
         AHI   14,L'MFMT8400-1     BUMP THE OUTPUT POINTER
         J     MFMT0100            GO DO THE NEXT FORMAT
MFMT5400 MVC   MFMTWEWK,MFMT8400   COPY EDIT MASK TO WORK AREA
         ED    MFMTWEWK,0(4)       TRANSLATE PACKED DECIMAL DIGITS    ->
                                    TO DECIMAL
         MVC   0(L'MFMT8400-1,14),MFMTWEWK+1  COPY TRANSLATED TIME    ->
                                    TO OUTPUT
         LA    15,L'MFMT8400-1(,14)  SET REG 15
MFMT5600 CLI   0(4),X'12'          COMPARE ORIGINAL TIME
         JNL   MFMT5700            BR IF PM
         MVC   0(3,15),=C' AM'     ADD AM TO OUTPUT
         CLI   0(4),X'00'          TEST IF 12 AM
         JNE   MFMT5800            BE IF NOT, WE'RE DONE
         MVC   0(2,14),=C'12'      CHANGE 00 TO 12
         J     MFMT5800            AND CONTINUE
MFMT5700 MVC   0(3,15),=C' PM'     INSERT PM
         CLI   0(4),X'12'          TEST IF NOON TO 12:59
         JE    MFMT5800            BR IF SO, TIME DOES NOT HAVE TO    ->
                                    ADJUSTED
         MVC   MFMTWWRK+4(4),0(4)  COPY ORIGINAL TIME TO WORK AREA
         OI    MFMTWWRK+7,X'0F'    SET A VALID SIGN
         SP    MFMTWWRK+4(4),=P'1200000'  ADJUST THE TIME
         MVC   MFMTWWRK(4),=X'402120'  COPY EDIT MASK
         ED    MFMTWWRK(4),MFMTWWRK+4  CONVERT ADJUSTED TIME TO DECIMAL
         MVC   0(2,14),MFMTWWRK+1  REPLACE HH WITH ADJUSTED HH
MFMT5800 LA    14,3(,15)           UPDATE OUTPUT POINTER
         J     MFMT0100            GO DO THE NEXT FORMAT
         CNOP  0,8
* GET THE ADDRESS.  REG 1 POINTS TO THE ADDRESS CONSTANT, REG 3
* POINTS TO THE FORMAT.  ON RETURN, REG 3 PONTS TO THE NEXT FORMAT,
* AND REG 4 CONTAINS THE OPERAND ADDRESS
MFMT5900 TM    0(3),X'40'          TEST IF S-TYPE ADDRESS
         JZ    MFMT6300            BR IF IN-LINE ADDRESS CONSTANT
MFMT6000 LH    2,0(,1)             LOAD OFFSET FROM THE BASE REGISTER
         N     2,=A(X'FFF')        ISOLATE THE OFFSET
         IC    4,0(,1)             LOAD REGISTER
         N     4,=A(X'F0')         ISOLATE THE REGISTER
         SRL   4,2                 TRANSLATE REGISTER VALUE TO WORD   ->
                                    OFFSET
         L     4,MFMT8100(4)       LOAD THE SAVE AREA OFFSET FOR THE  ->
                                    REGISTER
         CHI   4,99                TEST IF REG 13
         JNE   MFMT6100            BR IF NOT
         LR    4,13                COPY REG 13 TO REG 4
         J     MFMT6200            GO ADD THE OFFSET
MFMT6100 L     4,0(4,13)           LOAD THE BASE REGISTER FROM THE    ->
                                    SAVE AREA
MFMT6200 ALR   4,2                 ADD THE OFFSET TO THE BASE REGISTER
         LA    3,2(,1)             COMPUTE THE ADDRESS                ->
                                    OF THE NEXT FORMAT
         BR    15                  GO TO THE CONVERSION ROUTINE
MFMT6300 ICM   4,B'1111',0(1)      LOAD THE DATA ADDRESS
         LA    3,4(,1)             LOAD ADDRESS OF THE NEXT FORMAT
         BR    15                  GO TO THE CONVERSION ROUTINE
MFMT6400 J     MFMT7500            LENGTH 0, FORMAT ERROR
         IC    15,0(,4)            LENGTH 1, LOAD 1 BYTE
         ICM   15,B'0011',0(4)     LENGTH 2, LOAD 2 BYTES
         ICM   15,B'0111',0(4)     LENGTH 3, LOAD 3 BYTES
         ICM   15,B'1111',0(4)     LENGTH 4, LOAD 4 BYTES
MFMT6500 SR    15,15               SET REG 15 = 0
         L     1,=AL1(C' ',0,0,0)  LOAD FILL CHARACTER
         IC    15,1(,3)            LOAD NUMBER OF BLANKS TO INSERT
         AHI   3,2                 COMPUTE ADDRESS OF THE NEXT FORMAT
         MVCL  14,0                INSERT THE BLANKS
         J     MFMT0100            GO PROCESS THE NEXT FORMAT
* TRANSLATE DCBRECFM TO A CHARACTER STRING
MFMT6600 SR    6,6                 SET REG 6 = 0
         IC    6,2(,3)             LOAD THE OUTPUT LENGTH
         LA    1,3(,3)             LOAD ADDRESS OF THE ADDRESS
         BRAS  15,MFMT5900         GET THE ADDRESS
         MVC   MFMTWEWK(5),=CL8' ' CLEAR THE TEMPORARY OUTPUT
         TM    0(4),DCBRECL        TEST IF RECFM IS VALID
         JNZ   MFMT6610            BR IF A RECORD TYPE IS DEFINED
         MVI   MFMTWEWK,C'?'       INDICATE RECFM IS INVALID
         LA    15,MFMTWEWK+1       SET REG 15 = END OF DATA
         J     MFMT7200            AND EXIT
MFMT6610 LA    15,MFMTWEWK         LOAD ADDRESS OF THE TEMPORARY OUTPUT
         LA    0,MFMT7800          LOAD ENTRIES IN THE CONVERSION TABLE
         LA    1,MFMT7700          LOAD ADDR OF THE CONVERSION TABLE
MFMT6700 MVC   MFMTWEWK+5(1),0(4)  SAVE A COPY OF THE RECFM
         NC    MFMTWEWK+5(1),0(1)  ISOLATE TEST BITS
         CLC   MFMTWEWK+5(1),1(1)  TEST RECFM
         JNE   MFMT6800            BR OPTION NOT PRESENT
         MVC   0(1,15),2(1)        COPY THE OPTION CHARACTER
         AHI   15,1                UPDATE THE OUTPUT ADDR
MFMT6800 AHI   1,3                 COMPUTE ADDR OF NEXT RECFM         ->
                                    CONVERSION TABLE ENTRY
         BRCT  0,MFMT6700          GO DO IT
         J     MFMT7200
* TRANSLATE DCBDSORG TO A CHARACTER STRING
MFMT6900 SR    6,6                 SET OUTPUT LENGTH = 0
         IC    6,2(,3)             LOAD OUTPUT LENGTH
         LA    1,3(,3)             LOAD ADDRESS OF THE ADDRESS
         BRAS  15,MFMT5900         GET THE ACTUAL ADDRESS
         LA    0,MFMT8000          LOAD ENTRIES IN DSORG TABLE
         LA    1,MFMT7900          LOAD ADDR OF START OF THE DSORG TAB
MFMT7000 CLC   0(2,4),0(1)         TEST IF MATCH
         JE    MFMT7100            BE IF SO
         AHI   1,5                 COMPUTE ADDR OF NEXT DSORG ENTRY
         BRCT  0,MFMT7000          GO CHECK IT
MFMT7100 MVC   MFMTWEWK(3),2(1)    COPY DSORG TEXT
         LA    15,MFMTWEWK+3       LOAD END OF DSORG
         CLI   MFMTWEWK+2,C' '     TEST IF 3 BYTE DSORG
         BNE   MFMT7200            BR IF SO
         BCTR  15,0                RESET END OF DSORG
MFMT7200 LR    5,15                COPY END OF TEXT TO REG 5
         LA    4,MFMTWEWK          LOAD ADDRESS OF CONVERTED TEXT
         SR    5,4                 COMPUTE LENGTH OF CONVERTED TEXT
         LTR   6,6                 TEST OUTPUT LENGTH
         JNZ   *+L'*+2             BR IF OUTPUT LENGTH DEFINED
         LR    6,5                 COPY INPUT LENGTH TO OUTPUT LENGTH
         O     5,=AL1(C' ',0,0,0)  ADD FILL CHARACTER TO INPUT LENGTH
         LR    15,6                COPY OUTPUT LENGTH TO REG 15
         MVCL  14,4                COPY RECFM TEXT TO OUTPUT
         J     MFMT0100            GO DO THE NEXT FORMAT
* TAB -- REPOSITION OUTPUT POINTER, INSERT BLANKS IF TAB > CURRENT
*        LINE POSITION
MFMT7300 SR    15,15               SET REG 15 = 0
         IC    15,1(,3)            LOAD TAB POSITION
         AHI   3,2                 UPDATE FORMAT POSITION
         LA    15,MFMTWLNE+4(15)   COMPUTE TAB POSITION IN OUTPUT     ->
                                    BUFFER
         CR    15,14               COMPARE TAB POSITION W/ CURRENT    ->
                                    LINE POSITION
         JH    MFMT7400            BR IF FORWARD TAB
         JE    MFMT0100            NO MOVEMENT, IGNORE
         LR    14,15               BACKWARDS, SET NEW OUTPUT POSITION
         J     MFMT0100            GO DO THE NEXT FORMAT
MFMT7400 SR    15,14               COMPUTE NUMBER OF BLANKS TO INSERT
         L     1,=AL1(C' ',0,0,0)  LOAD FILL CHARACTER INTO REG 1
         MVCL  14,0                INSERT BLANKS TO NEW TAB
         J     MFMT0100            GO DO THE NEXT FORMAT
MFMT7500 MVC   0(5,14),=C'*FMT*'   INDICATE A FORMAT PROBLEM
         AHI   14,5                UPDATE THE OUTPUT POINTER
MFMT7600 LA    1,MFMTWLNE          LOAD ADDR OF GENERATED LINE
         SR    14,1                COMPUTE LENGTH OF GENERATED LINE
         STH   14,0(,1)            STORE LENGTH IN THE RDW
         XC    2(2,1),2(1)         CLEAR THE REMAINDER OF THE RDW
         ST    1,24(,13)           REPLACE CALLER'S REG 1 WITH        ->
                                    ADDRESS OF GENERATED OUTPUT LINE
         RETURN (14,12),T          RESTORE REGS & RETURN TO CALLER
MFMT7700 DC    AL1(DCBRECL,DCBRECF,C'F') TABLE TO
         DC    AL1(DCBRECL,DCBRECV,C'V')  TRANSLATE
         DC    AL1(DCBRECL,DCBRECU,C'U')   DCBRECFM
*        DC    AL1(DCBRECL,0,C'?')          TO A
         DC    AL1(DCBRECBR,DCBRECBR,C'B')   CHARACTER
         DC    AL1(DCBRECSB,DCBRECSB,C'S')    STRING
         DC    AL1(DCBRECTO,DCBRECTO,C'T')
         DC    AL1(DCBRECCC,DCBRECCA,C'A')
         DC    AL1(DCBRECCC,DCBRECCM,C'M')
MFMT7800 EQU   (*-MFMT7700)/3      NUMBER OF ENTRIES IN MFMT7700 TABLE
MFMT7900 DC    AL1(DCBDSGPS,0),CL3'PS'         TABLE TO
         DC    AL1(DCBDSGPO,0),CL3'PO'          TRANSLATE
         DC    AL1(DCBDSGIS,0),CL3'IS'           DCBDSORG
         DC    AL1(DCBDSGDA,0),CL3'DA'            TO A
         DC    AL1(0,DCBACBM),CL3'VS'              CHARACTER STRING
         DC    AL1(DCBDSGPS+DCBDSGU,0),CL3'PSU'
         DC    AL1(DCBDSGPO+DCBDSGU,0),CL3'POU'
         DC    AL1(DCBDSGIS+DCBDSGU,0),CL3'ISU'
         DC    AL1(DCBDSGDA+DCBDSGU,0),CL3'DAU'
MFMT8000 EQU   (*-MFMT7900)/5      NUMBER OF ENTRIES IN MFMT7900 TABLE
         DC    2AL1(0),CL3'??'
* THE MFMT8100 TABLE TRANSLATES A REGISTER NUMBER TO THE OFFSET
* OF THE REGISTER LOCATION IN THE SAVE AREA USED WHEN MINIFMT IS
* CALLED.  SINCE REGISTERS 14, 15, 0 AND 1 ARE LINK REGISTERS WHEN
* MICROFMT IS CALLED THEY ARE NOT VERY USEFUL FOR THE PURPOSE, BUT
* REGISTERS 2 THROUGH 13 ARE USEFUL.
*             REG 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
MFMT8100 DC    A(20,24,28,32,36,40,44,48,52,56,60,64,68,99,12,16)
MFMT8200 EQU   *-C'0'
         DC    C'0123456789ABCDEF'
*                  ----+----1----+
MFMT8300 DC    0C' 999999999999999',C' ',13X'20',X'2120'
MFMT8310 DC    0C' 999,999,999,999,999'
         DC    C' ',3X'20',C',',3X'20',C',',3X'20',C',',3X'20',C',',X'2>
               02120'
*                 0----+---
MFMT8400 DC    0C'0HH:MM:SS',C'0',X'2120',C':',X'2020',C':',X'2020'
* DAY OF YEAR FOR 1ST DAY OF MONTH
         DC    0H'0'
MFMT8500 EQU   *-2
         DC    AL2(0)                                JANUARY
         DC    AL2(31)                               FEBRUARY
         DC    AL2(31+29)                            MARCH
         DC    AL2(31+29+31)                         APRIL
         DC    AL2(31+29+31+30)                      MAY
         DC    AL2(31+29+31+30+31)                   JUNE
         DC    AL2(31+29+31+30+31+30)                JULY
         DC    AL2(31+29+31+30+31+30+31)             AUGUST
*                                                    ----+----
         DC    AL2(31+29+31+30+31+30+31+31)          SEPTEMBER
         DC    AL2(31+29+31+30+31+30+31+31+30)       OCTOBER
         DC    AL2(31+29+31+30+31+30+31+31+30+31)    NOVEMBER
         DC    AL2(31+29+31+30+31+30+31+31+30+31+30) DECEMBER
* TRANSLATE DAY OF YEAR TO MONTH
* JANUARY TO JUNE
MFMT8600 DC    32AL1(1),29AL1(2),31AL1(3),30AL1(4),31AL1(5),30AL1(6)
* JULY TO DECEMBER
         DC    31AL1(7),31AL1(8),30AL1(9),31AL1(10),30AL1(11),31AL1(12)
* MONTH NUMBER TO MONTH NAME, ABBREVIATED MONTH NAME IS THE FIRST 3
* CHARACTERS OF THE FULL MONTH NAME
MFMT8700 DC    CL9'--'
         DC    CL9'JANUARY',CL9'FEBRUARY',CL9'MARCH'
         DC    CL9'APRIL',CL9'MAY',CL9'JUNE'
         DC    CL9'JULY',CL9'AUGUST',CL9'SEPTEMBER'
         DC    CL9'OCTOBER',CL9'NOVEMBER',CL9'DECEMBER'
         DC    0D'0'
         LTORG ,
         DC    0D'0'
         DROP  ,
         TITLE 'CNVTBIN -- Translate Time of Day As Returned by TIME BI>
               N to Time of Day As Returned by TIME DEC'
***********************************************************************
*                                                                     *
* Title -- CNVTBIN                                                    *
*                                                                     *
* Function / Operation -- CNVTBIN converts the time of day as         *
*   returned by the TIME BIN macro to the time of day as returned     *
*   by the TIME DEC macro.                                            *
*                                                                     *
* Calling Sequence --                                                 *
*   ----+----1----+----2----+----3----+----4----+----5----+----6----+ *
*            TIME  BIN                 (or equivalent)                *
*            L     15,=V(CNVTBIN)      Load address of CNVTBIN        *
*            BASR  14,15               Convert binary time of day     *
*   *                                   to 8 packed decimal digits    *
*   * Time of day is in reg 0                                         *
*   * CNVTBIN can also be called using the BRAS or BRASL instructions *
*                                                                     *
* Status / Change Level --                                            *
*   V2L0 -- May 2010                                                  *
*    - Replace lost source                                            *
*                                                                     *
* Method of Operation -- Prepare a binary number that is the analog   *
*   of the number returned by TIME DEC, convert the number to the     *
*   5 byte equivalent of the packed decimal equivalent of the value   *
*   returned by TIME DEC, store the decimal digits in reg 0 and       *
*   return.                                                           *
*                                                                     *
***********************************************************************
         SPACE 5
         ENTRY CNVTBIN
         AGO   .NEWBIN
CNVTBIN  BASR  15,0                STORE CURRENT ADDRESS IN REG 15
         USING *,15                ESTABLISH ADDRESSABILITY
         SAVE  (14,3),,CNVTBIN     SAVE REGISTERS 14 THROUGH 3        ->
                                    (THE SAVE AREA POSITIONS FOR      ->
                                     REGISTERS 11 AND 12 WILL BE USED ->
                                      AS A WORK AREA)
         LR    3,0                 COPY THE TIME BIN VALUE TO REG 3
         SR    2,2                 SET REG 2 = 0
         D     2,=F'100'           DIVIDE BY NUMBER OF 1/100TH OF A   ->
                                    SECONDS IN A SECOND
         LR    0,2                 COPY 1/100THS OF A SECOND TO REG 0
         SR    2,2                 SET REG 2 = 0
         D     2,=F'60'            DIVIDE SECONDS BY SECONDS IN 1     ->
                                    MINUTE
         MHI   2,100               MULTIPLY SECONDS BY 100
         AR    0,2                 ADD TO TOTAL
         SR    2,2                 SET REG 2 = 0
         D     2,=F'60'            DIVIDE MINUTES BY 60
* WE HAVE MINUTES IN AN HOUR IN REG 2, AND THE HOUR OF THE DAY IN REG 3
         MHI   2,10000             MULTIPLY MINUTES BY 10000
         AR    0,2                 ADD TO TOTAL
         SR    2,2                 SET REG 2 = 0
         M     2,=F'1000000'       MULTIPLY HOUR OF THE DAY BY 1000000
         AR    0,3                 ADD TO TOTAL
         CVD   0,64(,13)           CONVERT TIME TO PACKED DECIMAL
         LM    0,1,64(13)          LOAD TIME
         SRDL  0,4                 REMOVE THE PACKED DECIMAL SIGN
         ST    1,20(,13)           REPLACE CALLER'S REG 0 WITH RESULT
         RETURN (14,3),T           RESTORE CALLER'S REGISTERS & RETURN
         DC    0D'0'               FORCE DOUBLE WORD ALIGNMENT
         LTORG ,                   DEFINE THE LITERAL POOL
         DC    0D'0'               FORCE DOUBLE WORD ALIGNMENT
         SPACE 1
         DROP  ,                   KILL ADDRESSABILITY
.NEWBIN  ANOP
CNVTBIN  BASR  15,0                Store current address in reg 15
         USING *,15                Establish addressability
         SAVE  (14,1),,CNVTBIN     Save registers
         LR    1,0                 Copy reg 0 to reg 1
         SR    0,0                 Compute minutes (in reg 1)
         D     0,=F'6000'           and seconds (in reg 0)
         LR    14,0                Copy seconds to reg 14
         SR    0,0                 Compute hours (in reg 1)
         D     0,=F'60'             and minutes (in reg 0)
         MHI   0,10000             Multiply minutes by 10000
         AR    14,0                Combine minutes and seconds
         MHI   1,1000              Multiply hours by 1000000
         MHI   1,1000
         AR    14,1                Combine hours with minutes & seconds
         MHI   14,10               Multiply F'hhmmssss' by 10
         CVD   14,64(,13)          Convert F'hhmmssss0' to decimal
         MVC   20(4,13),67(13)     Replace caller's reg 0 with hhmmssss
         RETURN (14,1)             Restore registers & return
         DC    0D'0'
         LTORG ,
         DC    0D'0'
         DROP   ,                  Kill addressability
         TITLE 'LJUST            L E F T   J U S T I F Y   R I G H T   >
               J U S T I F I E D   D A T A'
* Left justify right justified justifed data
*          LA    0,L'DATA
*          LA    1,DATA
*          L     15,=V(LJUST)
*          CALL  (15)
*          ...
* DATA     DC    C'  DATA'
*
* Output is C'DATA  '
*
* An alternative, slightly faster though more expensive in storage,
* inplementation is expressed in comments.
         SPACE 1
         ENTRY LJUST               Define external entry point
LJUST    BASR  15,0                Store current address in reg 15
         USING *,4                 Establish program addressability
         SAVE  (14,4),,LJUST       Save registers
         LR    4,15                Prepare base register
         LR    14,1                Copy start of data to reg 14 and
         LR    2,1                  reg 2
         LTR   3,0                 Copy length to reg 3
         JNP   LJ0300              Br if length is bad
**       LA    1,0(3,2)            Compute address of end of data
*        LR    15,0                Copy length to reg 15
*        BCTR  15,0                Compute length to test
*        EX    15,LJ0500           Find first non-blank
*        JZ    LJ0300              All blanka, exit
LJ0100   TM    0(1),255-C' '       Find first non-blank
         JNZ   LJ0200              Br if found
         AHI   1,1                 Update reg 1
         BRCT  0,LJ0100            Keep on looking
         J     LJ0300              All blanks, exit
LJ0200   CR    14,1                Test if already left justified
         JE    LJ0300              Br if so
         LA    15,0(3,2)           Compute addr of end of data
         SR    15,1                Compute length to copy
         JNP   LJ0300              Oops
         BCTR  15,0                Reduce length by 1 for hardware
         EX    15,LJ0400           Left justify the data
         LA    14,1(15,14)         Compute end of string we just copied
         LA    15,0(3,2)           Compute end of data
         SR    15,14               Compute bytes to blank
         JNP   LJ0300              Br if none
         L     1,LJ0600            Load the fill character
         MVCL  14,0                Fill the vacated data with blanks
LJ0300   RETURN (14,4)             Restore registers & return
LJ0400   MVC   0(*-*,14),0(1)    **EX only **
*LJ0500  TRT   0(*-*,14),LJ0700  **EX only **
LJ0600   DC    0A(0),C' ',3AL1(0)
         DC    0D'0'
*LJ0700  DC    X'00',(C' '-(*-LJ0700))X'04',X'00',(256-(*-LJ0700))X'04'
         END   ,
SMFETIME TITLE '       C O N V E R T   S M F   D A T E / T I M E   P A >
               I R S   T O   E L A P S E D   T I M E'
***********************************************************************
*                                                                     *
* Title -- SMFETIME                                                   *
*                                                                     *
* Function / Operation -- SMFETIME calculates the elapsed time        *
*   between two SMF date/time pairs.  An SMF date time pair is an     *
*   8 byte data area; the first 4 bytes are a binary time of day      *
*   and the second 4 bytes are a date as a packed decimal number      *
*   with the format P'0cyyddd'.  SMFETIME can handle dates that       *
*   extend to a second year.  In other words, the start date          *
*   can be in 2013 and the end date can be in 2014.                   *
*                                                                     *
*   SMFETIME verifies the input data is valid and reasonable.  The    *
*   first 4 bytes must be between 0 and 8639999 (23:59:59.99), and    *
*   the second 4 bytes must be packed decimal.                        *
*                                                                     *
* Calling Sequence --                                                 *
*            CALL SMFETIME,(start,end,RESULT) (or equivalent)         *
*            ...                                                      *
*   start    DC   F'time-of-day',PL4'0cyyddd'                         *
*   end      DC   F'time-of-day',PL4'0cyyddd'                         *
*   RESULT   DC   F'elapsed-time'                                     *
*                                                                     *
* Status / Change Level --                                            *
*  V1L2 April 2016                                                    *
*   * Correct TRTTAB2, again                                          *
*  V1L1 Jan 2016                                                      *
*   * Correct TRTTAB2                                                 *
*  V1L0 Feb 2014                                                      *
*                                                                     *
* Attributes -- SMFETIME is reenterable, refreshable and reusable.    *
*   It operates in any AMODE and RMODE that is compatible with        *
*   the caller; it is declared AMODE 31, RMODE ANY.  The result       *
*   is in units of 1/100th of a second.  The progran operates in      *
*   TCB mode, problem state and problem key.  Since it uses no        *
*   external resources, its APF status is undefined.                  *
*                                                                     *
* Register 15 return code -                                           *
*   0 -- The result area contains the elapsed time.                   *
*   4 -- The input data is invalid.                                   *
*        - The date areas are not packed decimal.                     *
*        - The time of day values are not in the range of 0 to        *
*          8639999.                                                   *
*        The result overflowed the capacity of a 32-bit register;     *
*        (248+ days).                                                 *
*                                                                     *
* Y2K -- SMFETIME is Y2K compliant.                                   *
*                                                                     *
* Y21K -- SMFETIME is Y21K compliant.                                 *
*                                                                     *
* Language Environment -- SMFETIME is LE compatible.  It saves and    *
*   restores the program mask since it detects and responds to fixed  *
*   point binary overflow. It does not alter registers 11 and 12.  It *
*   is not LE compliant since it does not use full LE compliant entry *
*   and exit conventions and does not obtain a proper DSA from the LE *
*   stack.                                                            *
*                                                                     *
* Restrictions -- SMFETIME uses the TP instruction to test the date   *
*   areas.  If the instruction is not available, SMFETIME will fail   *
*   with an S0C1 ABEND; if the Assembler does not support the         *
*   instruction the assembly will fail.  An alternate test using the  *
*   TRT instruction and two translate and test tables is provided as  *
*   comments.  This code has not been tested.                         *
*                                                                     *
*   SMFETIME requires z/Architecture level set 1.  This level set     *
*   does not provide the TP instruction but does include the relative *
*   branch instructions and immediate operand instructions.           *
*                                                                     *
*   SMFETIME saves the caller's program mask, sets the program mask   *
*   to binary 0s, while it executes, and restores it before it exits. *
*                                                                     *
***********************************************************************
         SPACE 5
SMFETIME RSECT                     DEFINE PROGRAM CSECT
SMFETIME AMODE 31                  DEFINE PROGRAM AMODE
SMFETIME RMODE ANY                 DEFINE PROGRAM RMODE
WORKAREA DSECT                     DEFINE WORK AREA DSECT
         ORG   WORKAREA+72-8       RESET POSITION TO THE SAVE AREA    ->
                                    REGISTER 11 AREA
DWORK    DS    D                   DEFINE A DOUBLE WORD WORK AREA
SMFETIME RSECT                     RETURN TO THE PROGRAM CSECT
         USING *,10                ESTABLISH PROGRAM ADDRESSABILITY
         USING WORKAREA,13         ESTABLISH WORK AREA ADDRESSABILITY
         SAVE  (14,10),,'SMFETIME &SYSDATE &SYSTIME'  SAVE REGISTERS
         LR    10,15               COPY ENTRY POINT ADDRESS TO REG 10
         IPM   5                   STORE THE PROGRAM MASK
         ICM   14,B'1000',=AL1(0)  SET THE PROGRAM MASK
         SPM   14                   WE WILL USE
         LM    2,4,0(1)            LOAD THE PARAMETER LIST
*        TRT   4(3,2),TRTTAB1      VERIFY
*        JNZ   EXIT4                THE
*        TRT   4(3,3),TRTTAB1        DATE
*        JNZ   EXIT4                  AREAS
*        TRT   7(1,2),TRTTAB2          CONTAIN
*        JNZ   EXIT4                    PACKED
*        TRT   7(1,3),TRTTAB2            DECIMAL
*        JNZ   EXIT4                      DATA
         TP    4(4,2)              TEST START DATE
         JNZ   EXIT4               BR IF NOT PACKED DECIMAL
         TP    4(4,3)              TEST END DATE
         JNZ   EXIT4               BR IF NOT PACKED DECIMAL
         ICM   0,B'1111',0(2)      LOAD STARTING TIME OF DAY
         JM    EXIT4               BR IF BAD
         ICM   1,B'1111',0(3)      LOAD ENDING TIME OF DAY
         JM    EXIT4               BR IF BAD
         C     0,=A(100*24*60*60)  TEST START TIME OF DAY
         JNL   EXIT4               BR IF TOO HIGH
         C     1,=A(100*24*60*60)  TEST END TIME OF DAY
         JNL   EXIT4               BR IF TOO HIGH
         CP    4(4,2),4(4,3)       TEST IF START DATE = END DATE
         JNE   MDAYS               BR IF NOT
         SR    1,0                 COMPUTE ELAPSED TIME
         ST    1,0(,4)             STORE ELAPSED TIME
         JM    EXIT4               BR IF BAD
         J     EXIT0               EXIT WITH A SMILE
MDAYS    ZAP   DWORK,4(4,2)        CONVERT START DATE
         CVB   7,DWORK              TO BINARY
         ZAP   DWORK,4(4,3)        CONVERT END DATE
         CVB   9,DWORK              TO BINARY
         SR    6,6                 SEPARATE
         SR    8,8                  CYY
         D     6,=F'1000'            AND
         D     8,=F'1000'             DDD
* REG CONTENTS
*  6  DAY OF YEAR OF STARTING DATE
*  7  CYY OF STARTING YEAR
*  8  DAY OF YEAR OF ENDING DATE
*  9  CYY OF ENDING YEAR
         LR    1,9                 COPY END CYY TO REG 1
         SR    1,7                 SUBTRACT END CYY FROM START CYY
         JZ    SAMEYEAR            BR IF END CYY = START CYY
         JM    EXIT4               BR IF END CYY < START CYY
         CHI   1,1                 TEST IF END CYY = START CYY + 1
         JNE   EXIT4               BR IF NOT
* DETERMINE IF STARTING CYY REPRESENTS A LEAP YEAR.  THIS IS THE FULL
* GREGORIAN LEAP YEAR CALCULATION.
         LR    1,7                 COPY START CYY TO REG 1
         AHI   1,1900              CONVERT START CYY TO TRUE YEAR
         LR    14,1                COPY START YEAR TO REG 14
         N     14,=A(B'11')        TEST IF POSSIBLE LEAP YEAR
         JNZ   NOTLEAP             BR IF NOT A LEAP YEAR
         LR    15,1                COPY START YEAR TO REG 15
         D     14,=F'100'          DIVIDE START YEAR BY 100
         LTR   14,14               TEST THE REMAINDER
         JNZ   ISLEAP              BR IF START YEAR IS NOT A CENTURY  ->
                                    YEAR
         N     15,=A(B'11')        TEST IF START YEAR IS A CENTURY    ->
                                    LEAP YEAR
         JZ    ISLEAP              BR IF SO
NOTLEAP  AHI   8,365               "NORMALIZE" THE END DAY OF YEAR
         J     SAMEYEAR
ISLEAP   AHI   8,366               "NORMALIZE" THE END DAY OF YEAR
* NOW COMPUTE THE ELAPSED TIME
SAMEYEAR CR    8,6                 COMPARE LAST DAY OF YEAR WITH      ->
                                    FIRST DAY OF YEAR
         JNH   EXIT4               BR IF LAST DAY <= FIRST DAY
* COMPUTE TIME ON THE FIRST DAY
         L     0,=A(100*24*60*60)  LOAD MIDNIGHT TIME OF DAY
         S     0,0(,2)             SUBTRACT START TIME OF DAY
* COMPUTE TIME ON INTERMEDIATE DAYS
NEXTDAY  AHI   6,1                 ADD 1 TO START DAY OF YEAR
         CR    6,8                 COMPARE WITH END DAY OF YEAR
         JE    LASTDAY             BR IF LAST DAY
         A     0,=A(100*24*60*60)  ADD TIME IN 1 FULL DAY
         JO    EXIT4               BR IF OVERFLOW
         J     NEXTDAY             AND DO IT AGAIN
* COMPUTE TIME ON THE LAST DAY
LASTDAY  A     0,0(,3)             ADD TIME IN THIS DAY
         JO    EXIT4               BR IF MATH OVERFLOW
         ST    0,0(,4)             STORE RESULT
EXIT0    SR    15,15               SET RC = 0
         J     EXIT
EXIT4    LHI   15,4                SET RC = 4
EXIT     SPM   5                   RESTORE THE CALLER'S PROGRAM MASK
         RETURN (14,10),T,RC=(15)  RESTORE REGISTERS & RETURN
         DC    0D'0'
* USE TRTTAB1 TO VERIFY THE FIRST 3 BYTES AND TRTTAB2 TO VERIFY THE
* 4TH BYTE OF PACKED DECIMAL DATA.
**                  0 1 2 3 4 5 6 7 8 9 A B C D E F
*TRTTAB1  DC    10X'00000000000000000000040404040404'
*         DC     6X'04040404040404040404040404040404'
*TRTTAB2  DC    10X'00000000000000000000000400040000'
*         DC     6X'04040404040404040404040404040404'
         LTORG ,                   DEFINE THE SMFETIME LITERALS
         DC    0D'0'               ROUND CSECT TO 8 BYTES
         END   ,
WEEKDAY  TITLE '                         Return Day of Week (0 through >
               6) As A Return Code'
***********************************************************************
*                                                                     *
* Title -- WEEKDAY                                                    *
*                                                                     *
* Function / Operation -- Return day of week as a number from 0       *
*   (Sunday) to 6 (Saturday) as a return code                         *
*                                                                     *
* Status / Change Level --                                            *
*   V1L0 -- July 2011                                                 *
*                                                                     *
* Method of Operation -- Get current time from the hardware time      *
*   of day clock.  Translate the value to days from Janury 1,         *
*   1900, then use that value to determine the current day of week.   *
*                                                                     *
* Attributes -- WEEKDAY is reenterable, refreshable and reusable.     *
*   It operates in TCB mode, in problem state and problem key.        *
*   WEEKDAY uses no external operating system services.  WEEKDAY is   *
*   declared as AMODE 31, RMODE ANY, but it will really run in any    *
*   AMODE that is compatible with the true RMODE of the program and   *
*   the location of the save area passed to WEEKDAY and the           *
*   address passed in register 14.                                    *
*                                                                     *
* Restrictions -- WEEKDAY uses register 0 as a 64 bit register, but   *
*   it does not save and restore the high order 32 bits of the        *
*   register.                                                         *
*                                                                     *
***********************************************************************
         SPACE 5
WEEKDAY  RSECT                     DEFINE PROGRAM CSECT
WEEKDAY  RMODE ANY                 ESTABLISH PROGRAM RMODE
WEEKDAY  AMODE 31                  ESTABLISH PROGRAM AMODE
         PUSH  PRINT
         PRINT NOGEN
         CVT   DSECT=YES           DEFINE THE CVT DATA AREA
         POP   PRINT
         SPACE 1
* DSECT FOR THE REGISTER SAVE AREA SUPPLIED BY THE CALLER.  THIS
* AREA IS USED AS BOTH A REGISTER SAVE AREA AND A WORK AREA
         SPACE 1
SA       DSECT
         DS    A                   RESERVER
SAPREV   DS    A                   ADDRESS OF PREVIOUS SAVE AREA
SANEXT   DS    A                   ADDRESS OF NEXT SAVE AREA
SAREG14  DS    A                   CALLER'S REG 14
SAREG15  DS    A                   CALLER'S REG 15
SAREG0   DS    A                   CALLER'S REG 0
SAREG1   DS    A                   CALLER'S REG 1
SAREG2   DS    A                   CALLER'S REG 2
SAREG3   DS    A                   CALLER'S REG 3
SAREG4   DS    A                   CALLER'S REG 4
SAREG5   DS    A                   CALLER'S REG 5
SAREG6   DS    A                   CALLER'S REG 6
SAREG7   DS    A                   CALLER'S REG 7
SAREG8   DS    A                   CALLER'S REG 8
SAREG9   DS    A                   CALLER'S REG 9
SAREG10  DS    A                   CALLER'S REG 10
CLOCK    DS    D
WEEKDAY  RSECT                     RETURN TO PROGRAM CSECT
         USING CVTXTNT2,2          EXTABLISH CVT EXTENSION            ->
                                    ADDRESSABILITY
         USING CVTMAP,3            ESTABLISH CVT ADDRESSABILITY
         USING *,4                 ESTABLISH PROGRAM ADDRESSABILITY
         USING SA,13               DEFINE SAVE AREA ADDRESSABILITY
         SAVE  (14,4),,'WEEKDAY &SYSDATE &SYSTIME'  SAVE REGISTERS
         LR    4,15                COPY ENTRY POINT ADDRESS TO REG 10
         L     3,CVTPTR            LOAD ADDRESS OF THE CVT
         L     2,CVTEXT2           LOAD ADDRSSS OF THE CVT EXTENSION
         STCK  CLOCK               GET THE CURRENT TOD CLOCK
         LG    0,CLOCK             LOAD CLOCK INTO 64-BIT REG 0
         SLG   0,CVTLSO            SUBTRACT LEAP SECONDS
         ALG   0,CVTLDTO           ADD TIMWZONE ADJUSTMENT
         STG   0,CLOCK             STORE ADJUSTED TOD CLOCK
         LM    0,1,CLOCK           LOAD THE CLOCK VALUE
         SRDL  0,12                CONVERT CLOCK VALUE TO             ->
                                    MICROSECONDS FROM JANUARY 1, 1900
* This is the trickiest part: we need a value <= 2**31-1, but large
* enough so that the quotient is <= 2**31-1
         D     0,=A(1000000*60)    CONVERT MICROSECONDS TO MINUTES    ->
                                    SINCE JANUARY 1, 1900
* REGISTER 1 CONTAINS MINUTES SINCE JANUARY 1, 1900
         SR    0,0                 SET REG 0 = 0
         D     0,=A(24*60)         COMPUTE NUMBER OF DAYS SINCE       ->
                                    JANUARY 1, 1900
         AHI   1,1                 ADD FUDGE FACTOR TO REG 1
         SR    0,0                 SET REG 0 = 0
         D     0,=F'7'             DIVIDE DAYS SINCE JANUARY 1, 1900  ->
                                    BY 7 TO GET THE DAY OF WEEK.
* REGISTER 0 CONTAINS THE DAY OF WEEK
         LR    15,0                COPY THE DAY OF WEEK TO REG 15
         RETURN (14,4),T,RC=(15)   RESTORE REGISTERS & RETURN
         DC    0D'0'
         LTORG ,
         DC    0D'0'
         END   WEEKDAY
